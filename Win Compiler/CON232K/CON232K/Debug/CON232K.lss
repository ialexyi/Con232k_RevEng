
CON232K.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800100  0000144e  000014e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000144e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000148  00800108  00800108  000014ea  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000014ea  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000198  00000000  00000000  0000151a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000020e6  00000000  00000000  000016b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007ad  00000000  00000000  00003798  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a1b  00000000  00000000  00003f45  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004bc  00000000  00000000  00004960  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000803  00000000  00000000  00004e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000141e  00000000  00000000  0000561f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000150  00000000  00000000  00006a3d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	fe c2       	rjmp	.+1532   	; 0x5fe <__ctors_end>
       2:	7b c8       	rjmp	.-3850   	; 0xfffff0fa <__eeprom_end+0xff7ef0fa>
       4:	17 c3       	rjmp	.+1582   	; 0x634 <__bad_interrupt>
       6:	16 c3       	rjmp	.+1580   	; 0x634 <__bad_interrupt>
       8:	15 c3       	rjmp	.+1578   	; 0x634 <__bad_interrupt>
       a:	d4 c8       	rjmp	.-3672   	; 0xfffff1b4 <__eeprom_end+0xff7ef1b4>
       c:	13 c3       	rjmp	.+1574   	; 0x634 <__bad_interrupt>
       e:	12 c3       	rjmp	.+1572   	; 0x634 <__bad_interrupt>
      10:	11 c3       	rjmp	.+1570   	; 0x634 <__bad_interrupt>
      12:	10 c3       	rjmp	.+1568   	; 0x634 <__bad_interrupt>
      14:	0f c3       	rjmp	.+1566   	; 0x634 <__bad_interrupt>
      16:	0e c3       	rjmp	.+1564   	; 0x634 <__bad_interrupt>
      18:	0d c3       	rjmp	.+1562   	; 0x634 <__bad_interrupt>
      1a:	0c c3       	rjmp	.+1560   	; 0x634 <__bad_interrupt>
      1c:	0b c3       	rjmp	.+1558   	; 0x634 <__bad_interrupt>
      1e:	0a c3       	rjmp	.+1556   	; 0x634 <__bad_interrupt>
      20:	09 c3       	rjmp	.+1554   	; 0x634 <__bad_interrupt>
      22:	08 c3       	rjmp	.+1552   	; 0x634 <__bad_interrupt>
      24:	9f c9       	rjmp	.-3266   	; 0xfffff364 <__eeprom_end+0xff7ef364>
      26:	d3 c9       	rjmp	.-3162   	; 0xfffff3ce <__eeprom_end+0xff7ef3ce>
      28:	05 c3       	rjmp	.+1546   	; 0x634 <__bad_interrupt>
      2a:	04 c3       	rjmp	.+1544   	; 0x634 <__bad_interrupt>
      2c:	03 c3       	rjmp	.+1542   	; 0x634 <__bad_interrupt>
      2e:	02 c3       	rjmp	.+1540   	; 0x634 <__bad_interrupt>
      30:	01 c3       	rjmp	.+1538   	; 0x634 <__bad_interrupt>
      32:	00 c3       	rjmp	.+1536   	; 0x634 <__bad_interrupt>
      34:	aa c4       	rjmp	.+2388   	; 0x98a <main+0x2e0>
      36:	99 c4       	rjmp	.+2354   	; 0x96a <main+0x2c0>
      38:	7d c5       	rjmp	.+2810   	; 0xb34 <main+0x48a>
      3a:	b7 c4       	rjmp	.+2414   	; 0x9aa <main+0x300>
      3c:	7b c5       	rjmp	.+2806   	; 0xb34 <main+0x48a>
      3e:	67 c4       	rjmp	.+2254   	; 0x90e <main+0x264>
      40:	c4 c4       	rjmp	.+2440   	; 0x9ca <main+0x320>
      42:	d3 c4       	rjmp	.+2470   	; 0x9ea <main+0x340>
      44:	d4 c4       	rjmp	.+2472   	; 0x9ee <main+0x344>
      46:	76 c5       	rjmp	.+2796   	; 0xb34 <main+0x48a>
      48:	75 c5       	rjmp	.+2794   	; 0xb34 <main+0x48a>
      4a:	74 c5       	rjmp	.+2792   	; 0xb34 <main+0x48a>
      4c:	73 c5       	rjmp	.+2790   	; 0xb34 <main+0x48a>
      4e:	72 c5       	rjmp	.+2788   	; 0xb34 <main+0x48a>
      50:	71 c5       	rjmp	.+2786   	; 0xb34 <main+0x48a>
      52:	70 c5       	rjmp	.+2784   	; 0xb34 <main+0x48a>
      54:	6f c5       	rjmp	.+2782   	; 0xb34 <main+0x48a>
      56:	cd c4       	rjmp	.+2458   	; 0x9f2 <main+0x348>
      58:	08 c5       	rjmp	.+2576   	; 0xa6a <main+0x3c0>
      5a:	f7 c4       	rjmp	.+2542   	; 0xa4a <main+0x3a0>
      5c:	65 c5       	rjmp	.+2762   	; 0xb28 <main+0x47e>
      5e:	09 c5       	rjmp	.+2578   	; 0xa72 <main+0x3c8>
      60:	63 c5       	rjmp	.+2758   	; 0xb28 <main+0x47e>
      62:	e3 c4       	rjmp	.+2502   	; 0xa2a <main+0x380>
      64:	1d c5       	rjmp	.+2618   	; 0xaa0 <main+0x3f6>
      66:	20 c5       	rjmp	.+2624   	; 0xaa8 <main+0x3fe>
      68:	2f c5       	rjmp	.+2654   	; 0xac8 <main+0x41e>
      6a:	5e c5       	rjmp	.+2748   	; 0xb28 <main+0x47e>
      6c:	5d c5       	rjmp	.+2746   	; 0xb28 <main+0x47e>
      6e:	5c c5       	rjmp	.+2744   	; 0xb28 <main+0x47e>
      70:	5b c5       	rjmp	.+2742   	; 0xb28 <main+0x47e>
      72:	5a c5       	rjmp	.+2740   	; 0xb28 <main+0x47e>
      74:	59 c5       	rjmp	.+2738   	; 0xb28 <main+0x47e>
      76:	58 c5       	rjmp	.+2736   	; 0xb28 <main+0x47e>
      78:	57 c5       	rjmp	.+2734   	; 0xb28 <main+0x47e>
      7a:	36 c5       	rjmp	.+2668   	; 0xae8 <main+0x43e>
      7c:	45 c5       	rjmp	.+2698   	; 0xb08 <main+0x45e>

0000007e <ScanCodeList>:
	...
      86:	00 00 00 06 14 1c f0 1c f0 14 00 00 00 00 05 e0     ................
      96:	1f e0 f0 1f 00 00 00 00 00 05 e0 2f e0 f0 2f 00     .........../../.
      a6:	00 00 00 00 05 e0 7d e0 f0 7d 00 00 00 00 00 05     ......}..}......
      b6:	e0 7a e0 f0 7a 00 00 00 00 00 05 e0 6c e0 f0 6c     .z..z.......l..l
      c6:	00 00 00 00 00 05 e0 69 e0 f0 69 00 00 00 00 00     .......i..i.....
      d6:	03 66 f0 66 00 00 00 00 00 00 00 03 0d f0 0d 00     .f.f............
      e6:	00 00 00 00 00 00 03 5a f0 5a 00 00 00 00 00 00     .......Z.Z......
      f6:	00 03 58 f0 58 00 00 00 00 00 00 00 06 14 12 f0     ..X.X...........
     106:	12 f0 14 00 00 00 00 06 14 5a f0 5a f0 14 00 00     .........Z.Z....
     116:	00 00 05 e0 71 e0 f0 71 00 00 00 00 00 03 05 f0     ....q..q........
     126:	05 00 00 00 00 00 00 00 03 06 f0 06 00 00 00 00     ................
     136:	00 00 00 03 04 f0 04 00 00 00 00 00 00 00 03 0c     ................
     146:	f0 0c 00 00 00 00 00 00 00 03 03 f0 03 00 00 00     ................
     156:	00 00 00 00 03 0b f0 0b 00 00 00 00 00 00 00 03     ................
     166:	83 f0 83 00 00 00 00 00 00 00 03 0a f0 0a 00 00     ................
     176:	00 00 00 00 00 03 01 f0 01 00 00 00 00 00 00 00     ................
     186:	03 09 f0 09 00 00 00 00 00 00 00 03 78 f0 78 00     ............x.x.
     196:	00 00 00 00 00 00 03 07 f0 07 00 00 00 00 00 00     ................
     1a6:	00 03 76 f0 76 00 00 00 00 00 00 00 03 14 00 00     ..v.v...........
     1b6:	00 00 00 00 00 00 00 03 f0 14 00 00 00 00 00 00     ................
     1c6:	00 00 01 11 00 00 00 00 00 00 00 00 00 03 f0 11     ................
	...
     1de:	03 29 f0 29 00 00 00 00 00 00 00 06 59 16 f0 16     .).)........Y...
     1ee:	f0 59 00 00 00 00 06 59 52 f0 52 f0 59 00 00 00     .Y.....YR.R.Y...
     1fe:	00 06 59 26 f0 26 f0 59 00 00 00 00 06 59 25 f0     ..Y&.&.Y.....Y%.
     20e:	25 f0 59 00 00 00 00 06 59 2e f0 2e f0 59 00 00     %.Y.....Y....Y..
     21e:	00 00 06 59 3d f0 3d f0 59 00 00 00 00 03 52 f0     ...Y=.=.Y.....R.
     22e:	52 00 00 00 00 00 00 00 06 59 46 f0 46 f0 59 00     R........YF.F.Y.
     23e:	00 00 00 06 59 45 f0 45 f0 59 00 00 00 00 06 59     ....YE.E.Y.....Y
     24e:	3e f0 3e f0 59 00 00 00 00 06 59 55 f0 55 f0 59     >.>.Y.....YU.U.Y
     25e:	00 00 00 00 03 41 f0 41 00 00 00 00 00 00 00 03     .....A.A........
     26e:	4e f0 4e 00 00 00 00 00 00 00 03 49 f0 49 00 00     N.N........I.I..
     27e:	00 00 00 00 00 03 4a f0 4a 00 00 00 00 00 00 00     ......J.J.......
     28e:	03 45 f0 45 00 00 00 00 00 00 00 03 16 f0 16 00     .E.E............
     29e:	00 00 00 00 00 00 03 1e f0 1e 00 00 00 00 00 00     ................
     2ae:	00 03 26 f0 26 00 00 00 00 00 00 00 03 25 f0 25     ..&.&........%.%
     2be:	00 00 00 00 00 00 00 03 2e f0 2e 00 00 00 00 00     ................
     2ce:	00 00 03 36 f0 36 00 00 00 00 00 00 00 03 3d f0     ...6.6........=.
     2de:	3d 00 00 00 00 00 00 00 03 3e f0 3e 00 00 00 00     =........>.>....
     2ee:	00 00 00 03 46 f0 46 00 00 00 00 00 00 00 06 59     ....F.F........Y
     2fe:	4c f0 4c f0 59 00 00 00 00 03 4c f0 4c 00 00 00     L.L.Y.....L.L...
     30e:	00 00 00 00 06 59 41 f0 41 f0 59 00 00 00 00 03     .....YA.A.Y.....
     31e:	55 f0 55 00 00 00 00 00 00 00 06 59 49 f0 49 f0     U.U........YI.I.
     32e:	59 00 00 00 00 06 59 4a f0 4a f0 59 00 00 00 00     Y.....YJ.J.Y....
     33e:	06 12 1e f0 1e f0 12 00 00 00 00 06 12 1c f0 1c     ................
     34e:	f0 12 00 00 00 00 06 12 32 f0 32 f0 12 00 00 00     ........2.2.....
     35e:	00 06 12 21 f0 21 f0 12 00 00 00 00 06 12 23 f0     ...!.!........#.
     36e:	23 f0 12 00 00 00 00 06 12 24 f0 24 f0 12 00 00     #........$.$....
     37e:	00 00 06 12 2b f0 2b f0 12 00 00 00 00 06 12 34     ....+.+........4
     38e:	f0 34 f0 12 00 00 00 00 06 12 33 f0 33 f0 12 00     .4........3.3...
     39e:	00 00 00 06 12 43 f0 43 f0 12 00 00 00 00 06 12     .....C.C........
     3ae:	3b f0 3b f0 12 00 00 00 00 06 12 42 f0 42 f0 12     ;.;........B.B..
     3be:	00 00 00 00 06 12 4b f0 4b f0 12 00 00 00 00 06     ......K.K.......
     3ce:	12 3a f0 3a f0 12 00 00 00 00 06 12 31 f0 31 f0     .:.:........1.1.
     3de:	12 00 00 00 00 06 12 44 f0 44 f0 12 00 00 00 00     .......D.D......
     3ee:	06 12 4d f0 4d f0 12 00 00 00 00 06 12 15 f0 15     ..M.M...........
     3fe:	f0 12 00 00 00 00 06 12 2d f0 2d f0 12 00 00 00     ........-.-.....
     40e:	00 06 12 1b f0 1b f0 12 00 00 00 00 06 12 2c f0     ..............,.
     41e:	2c f0 12 00 00 00 00 06 12 3c f0 3c f0 12 00 00     ,........<.<....
     42e:	00 00 06 12 2a f0 2a f0 12 00 00 00 00 06 12 1d     ....*.*.........
     43e:	f0 1d f0 12 00 00 00 00 06 12 22 f0 22 f0 12 00     .........."."...
     44e:	00 00 00 06 12 35 f0 35 f0 12 00 00 00 00 06 12     .....5.5........
     45e:	1a f0 1a f0 12 00 00 00 00 03 54 f0 54 00 00 00     ..........T.T...
     46e:	00 00 00 00 03 5d f0 5d 00 00 00 00 00 00 00 03     .....].]........
     47e:	5b f0 5b 00 00 00 00 00 00 00 06 12 36 f0 36 f0     [.[.........6.6.
     48e:	12 00 00 00 00 06 12 4e f0 4e f0 12 00 00 00 00     .......N.N......
     49e:	06 12 0e f0 0e f0 12 00 00 00 00 03 1c f0 1c 00     ................
     4ae:	00 00 00 00 00 00 03 32 f0 32 00 00 00 00 00 00     .......2.2......
     4be:	00 03 21 f0 21 00 00 00 00 00 00 00 03 23 f0 23     ..!.!........#.#
     4ce:	00 00 00 00 00 00 00 03 24 f0 24 00 00 00 00 00     ........$.$.....
     4de:	00 00 03 2b f0 2b 00 00 00 00 00 00 00 03 34 f0     ...+.+........4.
     4ee:	34 00 00 00 00 00 00 00 03 33 f0 33 00 00 00 00     4........3.3....
     4fe:	00 00 00 03 43 f0 43 00 00 00 00 00 00 00 03 3b     ....C.C........;
     50e:	f0 3b 00 00 00 00 00 00 00 03 42 f0 42 00 00 00     .;........B.B...
     51e:	00 00 00 00 03 4b f0 4b 00 00 00 00 00 00 00 03     .....K.K........
     52e:	3a f0 3a 00 00 00 00 00 00 00 03 31 f0 31 00 00     :.:........1.1..
     53e:	00 00 00 00 00 03 44 f0 44 00 00 00 00 00 00 00     ......D.D.......
     54e:	03 4d f0 4d 00 00 00 00 00 00 00 03 15 f0 15 00     .M.M............
     55e:	00 00 00 00 00 00 03 2d f0 2d 00 00 00 00 00 00     .......-.-......
     56e:	00 03 1b f0 1b 00 00 00 00 00 00 00 03 2c f0 2c     .............,.,
     57e:	00 00 00 00 00 00 00 03 3c f0 3c 00 00 00 00 00     ........<.<.....
     58e:	00 00 03 2a f0 2a 00 00 00 00 00 00 00 03 1d f0     ...*.*..........
     59e:	1d 00 00 00 00 00 00 00 03 22 f0 22 00 00 00 00     ........."."....
     5ae:	00 00 00 03 35 f0 35 00 00 00 00 00 00 00 03 1a     ....5.5.........
     5be:	f0 1a 00 00 00 00 00 00 00 06 12 54 f0 54 f0 12     ...........T.T..
     5ce:	00 00 00 00 06 12 5d f0 5d f0 12 00 00 00 00 06     ......].].......
     5de:	12 5b f0 5b f0 12 00 00 00 00 03 0e f0 0e 00 00     .[.[............
     5ee:	00 00 00 00 00 05 e0 71 e0 f0 71 00 00 00 00 00     .......q..q.....

000005fe <__ctors_end>:
     5fe:	11 24       	eor	r1, r1
     600:	1f be       	out	0x3f, r1	; 63
     602:	cf ef       	ldi	r28, 0xFF	; 255
     604:	d4 e0       	ldi	r29, 0x04	; 4
     606:	de bf       	out	0x3e, r29	; 62
     608:	cd bf       	out	0x3d, r28	; 61

0000060a <__do_copy_data>:
     60a:	11 e0       	ldi	r17, 0x01	; 1
     60c:	a0 e0       	ldi	r26, 0x00	; 0
     60e:	b1 e0       	ldi	r27, 0x01	; 1
     610:	ee e4       	ldi	r30, 0x4E	; 78
     612:	f4 e1       	ldi	r31, 0x14	; 20
     614:	02 c0       	rjmp	.+4      	; 0x61a <__do_copy_data+0x10>
     616:	05 90       	lpm	r0, Z+
     618:	0d 92       	st	X+, r0
     61a:	a8 30       	cpi	r26, 0x08	; 8
     61c:	b1 07       	cpc	r27, r17
     61e:	d9 f7       	brne	.-10     	; 0x616 <__do_copy_data+0xc>

00000620 <__do_clear_bss>:
     620:	22 e0       	ldi	r18, 0x02	; 2
     622:	a8 e0       	ldi	r26, 0x08	; 8
     624:	b1 e0       	ldi	r27, 0x01	; 1
     626:	01 c0       	rjmp	.+2      	; 0x62a <.do_clear_bss_start>

00000628 <.do_clear_bss_loop>:
     628:	1d 92       	st	X+, r1

0000062a <.do_clear_bss_start>:
     62a:	a0 35       	cpi	r26, 0x50	; 80
     62c:	b2 07       	cpc	r27, r18
     62e:	e1 f7       	brne	.-8      	; 0x628 <.do_clear_bss_loop>
     630:	3c d0       	rcall	.+120    	; 0x6aa <main>
     632:	0b c7       	rjmp	.+3606   	; 0x144a <_exit>

00000634 <__bad_interrupt>:
     634:	e5 cc       	rjmp	.-1590   	; 0x0 <__vectors>

00000636 <Set_Port_Bit>:
#include "allheaders.h"


void Set_Port_Bit( volatile uint8_t *PORT_ADDRESS , unsigned char ucBitNumber , unsigned char ucSingleBit )
{
	if ( ucSingleBit > 0 )
     636:	44 23       	and	r20, r20
     638:	79 f0       	breq	.+30     	; 0x658 <Set_Port_Bit+0x22>
		*PORT_ADDRESS |= 1 << ucBitNumber;
     63a:	fc 01       	movw	r30, r24
     63c:	40 81       	ld	r20, Z
     63e:	21 e0       	ldi	r18, 0x01	; 1
     640:	30 e0       	ldi	r19, 0x00	; 0
     642:	f9 01       	movw	r30, r18
     644:	02 c0       	rjmp	.+4      	; 0x64a <Set_Port_Bit+0x14>
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	6a 95       	dec	r22
     64c:	e2 f7       	brpl	.-8      	; 0x646 <Set_Port_Bit+0x10>
     64e:	bf 01       	movw	r22, r30
     650:	64 2b       	or	r22, r20
     652:	fc 01       	movw	r30, r24
     654:	60 83       	st	Z, r22
     656:	08 95       	ret
	else
		*PORT_ADDRESS &= ~( 1 << ucBitNumber );
     658:	fc 01       	movw	r30, r24
     65a:	40 81       	ld	r20, Z
     65c:	21 e0       	ldi	r18, 0x01	; 1
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	f9 01       	movw	r30, r18
     662:	02 c0       	rjmp	.+4      	; 0x668 <Set_Port_Bit+0x32>
     664:	ee 0f       	add	r30, r30
     666:	ff 1f       	adc	r31, r31
     668:	6a 95       	dec	r22
     66a:	e2 f7       	brpl	.-8      	; 0x664 <Set_Port_Bit+0x2e>
     66c:	bf 01       	movw	r22, r30
     66e:	60 95       	com	r22
     670:	64 23       	and	r22, r20
     672:	fc 01       	movw	r30, r24
     674:	60 83       	st	Z, r22
     676:	08 95       	ret

00000678 <SetDeviceToHostDirection>:
}

void SetDeviceToHostDirection(void)			// Sending to Host Clock and Data
{
	cli();
     678:	f8 94       	cli

	DDRD =  ( 1 << HOST_DATA_BIT ) | ( 1 << HOST_CLOCK_BIT );
     67a:	80 e6       	ldi	r24, 0x60	; 96
     67c:	8a b9       	out	0x0a, r24	; 10
	PORTD = ( 1 << HOST_DATA_BIT ) | ( 1 << HOST_CLOCK_BIT );
     67e:	8b b9       	out	0x0b, r24	; 11
     680:	08 95       	ret

00000682 <ReadingFromHostDirection>:
}

void ReadingFromHostDirection(void)			// Sending to Host Clock and Reading Data
{
	cli();
     682:	f8 94       	cli

	DDRD = ( 1 << HOST_CLOCK_BIT );
     684:	80 e2       	ldi	r24, 0x20	; 32
     686:	8a b9       	out	0x0a, r24	; 10
	PORTD = ( 1 << HOST_CLOCK_BIT );
     688:	8b b9       	out	0x0b, r24	; 11
     68a:	08 95       	ret

0000068c <ListeningtDirection>:
}

void ListeningtDirection(void)
{
	cli();
     68c:	f8 94       	cli

	DDRD = 0x00;
     68e:	1a b8       	out	0x0a, r1	; 10
	PORTD = 0x00;
     690:	1b b8       	out	0x0b, r1	; 11

	sei();
     692:	78 94       	sei
     694:	08 95       	ret

00000696 <SetHostToDeviceDirection>:
}

void SetHostToDeviceDirection(void)
{
	cli();
     696:	f8 94       	cli

	DDRD = ( 1 << DEVICE_DATA_BIT ) | ( 1 << DEVICE_CLOCK_BIT );
     698:	84 e8       	ldi	r24, 0x84	; 132
     69a:	8a b9       	out	0x0a, r24	; 10
	PORTD = ( 1 << DEVICE_DATA_BIT ) | ( 1 << DEVICE_CLOCK_BIT );
     69c:	8b b9       	out	0x0b, r24	; 11
     69e:	08 95       	ret

000006a0 <WritingToDeviceDirection>:
}

void WritingToDeviceDirection(void)			// Writing to Device Data
{
	cli();
     6a0:	f8 94       	cli

	DDRD = ( 1 << DEVICE_DATA_BIT );
     6a2:	80 e8       	ldi	r24, 0x80	; 128
     6a4:	8a b9       	out	0x0a, r24	; 10
	PORTD = ( 1 << DEVICE_DATA_BIT );
     6a6:	8b b9       	out	0x0b, r24	; 11
     6a8:	08 95       	ret

000006aa <main>:
{
	DDRC = 0x0F;
}

int main( void )
{
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
     6b2:	a3 97       	sbiw	r28, 0x23	; 35
     6b4:	0f b6       	in	r0, 0x3f	; 63
     6b6:	f8 94       	cli
     6b8:	de bf       	out	0x3e, r29	; 62
     6ba:	0f be       	out	0x3f, r0	; 63
     6bc:	cd bf       	out	0x3d, r28	; 61
	volatile unsigned short					BoudRateArray[4]						=	{UBRR_VALUE_19200,UBRR_VALUE_9600,UBRR_VALUE_4800,UBRR_VALUE_2400};
     6be:	88 e0       	ldi	r24, 0x08	; 8
     6c0:	e0 e0       	ldi	r30, 0x00	; 0
     6c2:	f1 e0       	ldi	r31, 0x01	; 1
     6c4:	de 01       	movw	r26, r28
     6c6:	11 96       	adiw	r26, 0x01	; 1
     6c8:	01 90       	ld	r0, Z+
     6ca:	0d 92       	st	X+, r0
     6cc:	8a 95       	dec	r24
     6ce:	e1 f7       	brne	.-8      	; 0x6c8 <main+0x1e>
	volatile unsigned char					BoudrateModeIndex						=	0;
     6d0:	19 86       	std	Y+9, r1	; 0x09
	volatile unsigned char					CurrentReceivedByte						=	0,
     6d2:	1a 86       	std	Y+10, r1	; 0x0a
												CommandReceivedByte						=	0,
     6d4:	1b 86       	std	Y+11, r1	; 0x0b
												PreviousCommandByte						=	0,
     6d6:	1c 86       	std	Y+12, r1	; 0x0c
												KeyCodeQuantity							=	0,
     6d8:	1d 86       	std	Y+13, r1	; 0x0d
												RepeatLastSend							=	0,
     6da:	1e 86       	std	Y+14, r1	; 0x0e
												LastSentByte							=	0,
     6dc:	1f 86       	std	Y+15, r1	; 0x0f
												iKeyCodeIndex							=	0,
     6de:	18 8a       	std	Y+16, r1	; 0x10
												DeviceAlive								=	0;
     6e0:	19 8a       	std	Y+17, r1	; 0x11

	volatile unsigned char					StoreLedsState							=	0,
     6e2:	1a 8a       	std	Y+18, r1	; 0x12
												StoreLedsStateUpdated					=	0,
     6e4:	1b 8a       	std	Y+19, r1	; 0x13
												StoreScanCodeState						=	0,
     6e6:	1c 8a       	std	Y+20, r1	; 0x14
												StoreScanCodeStateUpdated				=	0,
     6e8:	1d 8a       	std	Y+21, r1	; 0x15
												StoreAutoRateState 						= 	0,
     6ea:	1e 8a       	std	Y+22, r1	; 0x16
												StoreAutoRateStateUpdated 				=	0,
     6ec:	1f 8a       	std	Y+23, r1	; 0x17
												StoreEnableStateUpdated 				=	0,
     6ee:	18 8e       	std	Y+24, r1	; 0x18
												StoreDisableStateUpdated 				=	0;
     6f0:	19 8e       	std	Y+25, r1	; 0x19

	volatile unsigned char 					CodeArray[MAX_NUMBER_OF_CODE_KEYS]		=	{0};
     6f2:	fe 01       	movw	r30, r28
     6f4:	7a 96       	adiw	r30, 0x1a	; 26
     6f6:	8a e0       	ldi	r24, 0x0A	; 10
     6f8:	df 01       	movw	r26, r30
     6fa:	1d 92       	st	X+, r1
     6fc:	8a 95       	dec	r24
     6fe:	e9 f7       	brne	.-6      	; 0x6fa <main+0x50>
#define UBRR_VALUE_4800 	(((F_CPU / (4800UL * 16UL))) - 1)
#define UBRR_VALUE_2400 	(((F_CPU / (2400UL * 16UL))) - 1)

void SystemInit(void)
{
	DDRC = 0x0F;
     700:	8f e0       	ldi	r24, 0x0F	; 15
     702:	87 b9       	out	0x07, r24	; 7

	volatile unsigned char 					CodeArray[MAX_NUMBER_OF_CODE_KEYS]		=	{0};

	SystemInit();

	BoudrateModeIndex = ( PORTB >> 6 ) & 0x03;					// Read Baud Rate configuration from Port B (4,5)
     704:	85 b1       	in	r24, 0x05	; 5
     706:	82 95       	swap	r24
     708:	86 95       	lsr	r24
     70a:	86 95       	lsr	r24
     70c:	83 70       	andi	r24, 0x03	; 3
     70e:	89 87       	std	Y+9, r24	; 0x09

	USART_Init( BoudRateArray[BoudrateModeIndex] );
     710:	e9 85       	ldd	r30, Y+9	; 0x09
     712:	f0 e0       	ldi	r31, 0x00	; 0
     714:	ee 0f       	add	r30, r30
     716:	ff 1f       	adc	r31, r31
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	90 e0       	ldi	r25, 0x00	; 0
     71c:	8c 0f       	add	r24, r28
     71e:	9d 1f       	adc	r25, r29
     720:	e8 0f       	add	r30, r24
     722:	f9 1f       	adc	r31, r25
     724:	80 81       	ld	r24, Z
     726:	91 81       	ldd	r25, Z+1	; 0x01
     728:	05 d6       	rcall	.+3082   	; 0x1334 <USART_Init>

	Ps2Init();
     72a:	d2 d4       	rcall	.+2468   	; 0x10d0 <Ps2Init>

	PORTC = 0x00;												// Set All LEDs
     72c:	18 b8       	out	0x08, r1	; 8

	//Send Reset Command to Device
	SetHostToDeviceDirection();
     72e:	b3 df       	rcall	.-154    	; 0x696 <SetHostToDeviceDirection>
	Write_Ps2_HOST_REQUEST( &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT );
     730:	47 e0       	ldi	r20, 0x07	; 7
     732:	62 e0       	ldi	r22, 0x02	; 2
     734:	8b e2       	ldi	r24, 0x2B	; 43
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	9c d4       	rcall	.+2360   	; 0x1072 <Write_Ps2_HOST_REQUEST>
	WritingToDeviceDirection();
     73a:	b2 df       	rcall	.-156    	; 0x6a0 <WritingToDeviceDirection>
	Push_PS2_Byte( &PIND , &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT , DEVICE_RESET_COMMAND );
     73c:	0f ef       	ldi	r16, 0xFF	; 255
     73e:	27 e0       	ldi	r18, 0x07	; 7
     740:	42 e0       	ldi	r20, 0x02	; 2
     742:	6b e2       	ldi	r22, 0x2B	; 43
     744:	70 e0       	ldi	r23, 0x00	; 0
     746:	89 e2       	ldi	r24, 0x29	; 41
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	f9 d3       	rcall	.+2034   	; 0xf3e <Push_PS2_Byte>
	LastSentByte = DEVICE_RESET_COMMAND;
     74c:	8f ef       	ldi	r24, 0xFF	; 255
     74e:	8f 87       	std	Y+15, r24	; 0x0f
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     750:	9f ef       	ldi	r25, 0xFF	; 255
     752:	a9 e6       	ldi	r26, 0x69	; 105
     754:	b8 e1       	ldi	r27, 0x18	; 24
     756:	91 50       	subi	r25, 0x01	; 1
     758:	a0 40       	sbci	r26, 0x00	; 0
     75a:	b0 40       	sbci	r27, 0x00	; 0
     75c:	e1 f7       	brne	.-8      	; 0x756 <main+0xac>
     75e:	00 c0       	rjmp	.+0      	; 0x760 <main+0xb6>
     760:	00 00       	nop

	_delay_ms(1000);

	//Send trigger to Host
	SetDeviceToHostDirection();
     762:	8a df       	rcall	.-236    	; 0x678 <SetDeviceToHostDirection>
	Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , ACKNOWLEDGEMENT );
     764:	2a ef       	ldi	r18, 0xFA	; 250
     766:	46 e0       	ldi	r20, 0x06	; 6
     768:	65 e0       	ldi	r22, 0x05	; 5
     76a:	8b e2       	ldi	r24, 0x2B	; 43
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	61 d3       	rcall	.+1730   	; 0xe32 <Write_Ps2_Byte>

	PORTC = 0x07;												// Clear All LEDs
     770:	87 e0       	ldi	r24, 0x07	; 7
     772:	88 b9       	out	0x08, r24	; 8

	//Enable global interrupts
	sei();
     774:	78 94       	sei

	Set_Port_Bit( &PORTC , YELLOW_LED_BIT , LED_ON );								// Yellow LED ON ( Ready )
     776:	40 e0       	ldi	r20, 0x00	; 0
     778:	62 e0       	ldi	r22, 0x02	; 2
     77a:	88 e2       	ldi	r24, 0x28	; 40
     77c:	90 e0       	ldi	r25, 0x00	; 0
     77e:	5b df       	rcall	.-330    	; 0x636 <Set_Port_Bit>

	ListeningtDirection();
     780:	85 df       	rcall	.-246    	; 0x68c <ListeningtDirection>

	while (1) 													// Loop forever
	{
		if ( iKeyCodeIndex >= KeyCodeQuantity ) // Disable Device for Sending to host
     782:	98 89       	ldd	r25, Y+16	; 0x10
     784:	8d 85       	ldd	r24, Y+13	; 0x0d
     786:	98 17       	cp	r25, r24
     788:	08 f4       	brcc	.+2      	; 0x78c <main+0xe2>
     78a:	81 c0       	rjmp	.+258    	; 0x88e <main+0x1e4>
		{
			/* If Led data change send to device first command byte */
			if ( StoreLedsStateUpdated == 1 )
     78c:	8b 89       	ldd	r24, Y+19	; 0x13
     78e:	81 30       	cpi	r24, 0x01	; 1
     790:	a9 f4       	brne	.+42     	; 0x7bc <main+0x112>
			{
				SetHostToDeviceDirection();
     792:	81 df       	rcall	.-254    	; 0x696 <SetHostToDeviceDirection>
				Write_Ps2_HOST_REQUEST( &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT );
     794:	47 e0       	ldi	r20, 0x07	; 7
     796:	62 e0       	ldi	r22, 0x02	; 2
     798:	8b e2       	ldi	r24, 0x2B	; 43
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	6a d4       	rcall	.+2260   	; 0x1072 <Write_Ps2_HOST_REQUEST>
				WritingToDeviceDirection();
     79e:	80 df       	rcall	.-256    	; 0x6a0 <WritingToDeviceDirection>
				Push_PS2_Byte( &PIND , &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT , DEVICE_LED_SET );
     7a0:	0d ee       	ldi	r16, 0xED	; 237
     7a2:	27 e0       	ldi	r18, 0x07	; 7
     7a4:	42 e0       	ldi	r20, 0x02	; 2
     7a6:	6b e2       	ldi	r22, 0x2B	; 43
     7a8:	70 e0       	ldi	r23, 0x00	; 0
     7aa:	89 e2       	ldi	r24, 0x29	; 41
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	c7 d3       	rcall	.+1934   	; 0xf3e <Push_PS2_Byte>
				ListeningtDirection();
     7b0:	6d df       	rcall	.-294    	; 0x68c <ListeningtDirection>

				LastSentByte = DEVICE_LED_SET;
     7b2:	8d ee       	ldi	r24, 0xED	; 237
     7b4:	8f 87       	std	Y+15, r24	; 0x0f
				StoreLedsStateUpdated++;
     7b6:	8b 89       	ldd	r24, Y+19	; 0x13
     7b8:	8f 5f       	subi	r24, 0xFF	; 255
     7ba:	8b 8b       	std	Y+19, r24	; 0x13
			}

			/* Process data received from Device */
			if ( IsDataInPs2SnifferBuffer())
     7bc:	e7 d4       	rcall	.+2510   	; 0x118c <IsDataInPs2SnifferBuffer>
     7be:	88 23       	and	r24, r24
     7c0:	09 f4       	brne	.+2      	; 0x7c4 <main+0x11a>
     7c2:	54 c0       	rjmp	.+168    	; 0x86c <main+0x1c2>
			{
				DeviceAlive = 1;
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	89 8b       	std	Y+17, r24	; 0x11
				CurrentReceivedByte = GetDataFromPs2SnifferBuffer();
     7c8:	ea d4       	rcall	.+2516   	; 0x119e <GetDataFromPs2SnifferBuffer>
     7ca:	8a 87       	std	Y+10, r24	; 0x0a

				switch(CurrentReceivedByte)
     7cc:	8a 85       	ldd	r24, Y+10	; 0x0a
     7ce:	8a 3f       	cpi	r24, 0xFA	; 250
     7d0:	61 f0       	breq	.+24     	; 0x7ea <main+0x140>
     7d2:	28 f4       	brcc	.+10     	; 0x7de <main+0x134>
     7d4:	88 23       	and	r24, r24
     7d6:	a9 f1       	breq	.+106    	; 0x842 <main+0x198>
     7d8:	8a 3a       	cpi	r24, 0xAA	; 170
     7da:	c9 f5       	brne	.+114    	; 0x84e <main+0x1a4>
     7dc:	32 c0       	rjmp	.+100    	; 0x842 <main+0x198>
     7de:	8e 3f       	cpi	r24, 0xFE	; 254
     7e0:	01 f1       	breq	.+64     	; 0x822 <main+0x178>
     7e2:	78 f5       	brcc	.+94     	; 0x842 <main+0x198>
     7e4:	8c 3f       	cpi	r24, 0xFC	; 252
     7e6:	99 f5       	brne	.+102    	; 0x84e <main+0x1a4>
     7e8:	2c c0       	rjmp	.+88     	; 0x842 <main+0x198>
				{
					case ACKNOWLEDGEMENT:

							if ( StoreLedsStateUpdated == 2 )
     7ea:	8b 89       	ldd	r24, Y+19	; 0x13
     7ec:	82 30       	cpi	r24, 0x02	; 2
     7ee:	a1 f4       	brne	.+40     	; 0x818 <main+0x16e>
							{ // Send second Led Data contain byte
								SetHostToDeviceDirection();
     7f0:	52 df       	rcall	.-348    	; 0x696 <SetHostToDeviceDirection>
								Write_Ps2_HOST_REQUEST( &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT );
     7f2:	47 e0       	ldi	r20, 0x07	; 7
     7f4:	62 e0       	ldi	r22, 0x02	; 2
     7f6:	8b e2       	ldi	r24, 0x2B	; 43
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	3b d4       	rcall	.+2166   	; 0x1072 <Write_Ps2_HOST_REQUEST>
								WritingToDeviceDirection();
     7fc:	51 df       	rcall	.-350    	; 0x6a0 <WritingToDeviceDirection>
								Push_PS2_Byte( &PIND , &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT , StoreLedsState );
     7fe:	0a 89       	ldd	r16, Y+18	; 0x12
     800:	27 e0       	ldi	r18, 0x07	; 7
     802:	42 e0       	ldi	r20, 0x02	; 2
     804:	6b e2       	ldi	r22, 0x2B	; 43
     806:	70 e0       	ldi	r23, 0x00	; 0
     808:	89 e2       	ldi	r24, 0x29	; 41
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	98 d3       	rcall	.+1840   	; 0xf3e <Push_PS2_Byte>
								LastSentByte = StoreLedsState;
     80e:	8a 89       	ldd	r24, Y+18	; 0x12
     810:	8f 87       	std	Y+15, r24	; 0x0f
								StoreLedsStateUpdated++;
     812:	8b 89       	ldd	r24, Y+19	; 0x13
     814:	8f 5f       	subi	r24, 0xFF	; 255
     816:	8b 8b       	std	Y+19, r24	; 0x13
							}

							if ( StoreLedsStateUpdated == 3 )
     818:	8b 89       	ldd	r24, Y+19	; 0x13
     81a:	83 30       	cpi	r24, 0x03	; 3
     81c:	09 f5       	brne	.+66     	; 0x860 <main+0x1b6>
								StoreLedsStateUpdated = 0;
     81e:	1b 8a       	std	Y+19, r1	; 0x13
     820:	1f c0       	rjmp	.+62     	; 0x860 <main+0x1b6>

							break;

					case DEVICE_REPEAT_REQ:

							SetHostToDeviceDirection();
     822:	39 df       	rcall	.-398    	; 0x696 <SetHostToDeviceDirection>
							Write_Ps2_HOST_REQUEST( &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT );
     824:	47 e0       	ldi	r20, 0x07	; 7
     826:	62 e0       	ldi	r22, 0x02	; 2
     828:	8b e2       	ldi	r24, 0x2B	; 43
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	22 d4       	rcall	.+2116   	; 0x1072 <Write_Ps2_HOST_REQUEST>
							WritingToDeviceDirection();
     82e:	38 df       	rcall	.-400    	; 0x6a0 <WritingToDeviceDirection>
							Push_PS2_Byte( &PIND , &PORTD , DEVICE_CLOCK_BIT  , DEVICE_DATA_BIT , LastSentByte );
     830:	0f 85       	ldd	r16, Y+15	; 0x0f
     832:	27 e0       	ldi	r18, 0x07	; 7
     834:	42 e0       	ldi	r20, 0x02	; 2
     836:	6b e2       	ldi	r22, 0x2B	; 43
     838:	70 e0       	ldi	r23, 0x00	; 0
     83a:	89 e2       	ldi	r24, 0x29	; 41
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	7f d3       	rcall	.+1790   	; 0xf3e <Push_PS2_Byte>

							break;
     840:	0f c0       	rjmp	.+30     	; 0x860 <main+0x1b6>

					case DEVICE_FEEDBACK_ERROR:
					case BAT_PASS:
					case BAT_FAIL:
					case 0:
							if ( StoreLedsStateUpdated == 3 )
     842:	8b 89       	ldd	r24, Y+19	; 0x13
     844:	83 30       	cpi	r24, 0x03	; 3
     846:	61 f4       	brne	.+24     	; 0x860 <main+0x1b6>
								StoreLedsStateUpdated = 2;
     848:	82 e0       	ldi	r24, 0x02	; 2
     84a:	8b 8b       	std	Y+19, r24	; 0x13
     84c:	09 c0       	rjmp	.+18     	; 0x860 <main+0x1b6>

							break;
					default:
							SetDeviceToHostDirection();
     84e:	14 df       	rcall	.-472    	; 0x678 <SetDeviceToHostDirection>
							Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , CurrentReceivedByte );
     850:	2a 85       	ldd	r18, Y+10	; 0x0a
     852:	46 e0       	ldi	r20, 0x06	; 6
     854:	65 e0       	ldi	r22, 0x05	; 5
     856:	8b e2       	ldi	r24, 0x2B	; 43
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	eb d2       	rcall	.+1494   	; 0xe32 <Write_Ps2_Byte>
							RepeatLastSend = CurrentReceivedByte;
     85c:	8a 85       	ldd	r24, Y+10	; 0x0a
     85e:	8e 87       	std	Y+14, r24	; 0x0e
							break;
				}

				ListeningtDirection();
     860:	15 df       	rcall	.-470    	; 0x68c <ListeningtDirection>

				Set_Port_Bit( &PORTC , GREEN_LED_BIT , LED_OFF );								// Green LED OFF ( Device Sending )
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	61 e0       	ldi	r22, 0x01	; 1
     866:	88 e2       	ldi	r24, 0x28	; 40
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	e5 de       	rcall	.-566    	; 0x636 <Set_Port_Bit>
			}

			/* Pop Single Byte from RS232 and code it to Scan code*/
			if ( DataInReceiveBuffer())
     86c:	da d5       	rcall	.+2996   	; 0x1422 <DataInReceiveBuffer>
     86e:	88 23       	and	r24, r24
     870:	71 f0       	breq	.+28     	; 0x88e <main+0x1e4>
			{
				CurrentReceivedByte = GetDataFromReceiveBuffer();
     872:	e0 d5       	rcall	.+3008   	; 0x1434 <GetDataFromReceiveBuffer>
     874:	8a 87       	std	Y+10, r24	; 0x0a

				KeyCodeQuantity = GetScanCode( CurrentReceivedByte , CodeArray );
     876:	8a 85       	ldd	r24, Y+10	; 0x0a
     878:	be 01       	movw	r22, r28
     87a:	66 5e       	subi	r22, 0xE6	; 230
     87c:	7f 4f       	sbci	r23, 0xFF	; 255
     87e:	19 d5       	rcall	.+2610   	; 0x12b2 <GetScanCode>
     880:	8d 87       	std	Y+13, r24	; 0x0d

				iKeyCodeIndex = 0;
     882:	18 8a       	std	Y+16, r1	; 0x10

				Set_Port_Bit( &PORTC , RED_LED_BIT , LED_OFF );								// Red LED OFF ( Rs232 Sending )
     884:	41 e0       	ldi	r20, 0x01	; 1
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	88 e2       	ldi	r24, 0x28	; 40
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	d4 de       	rcall	.-600    	; 0x636 <Set_Port_Bit>
			}
		}
		/* If is not received request from host send scan code to host*/
		if (( iKeyCodeIndex < KeyCodeQuantity ) && ( IsDataInPs2HostBuffer() == 0 ))
     88e:	98 89       	ldd	r25, Y+16	; 0x10
     890:	8d 85       	ldd	r24, Y+13	; 0x0d
     892:	98 17       	cp	r25, r24
     894:	38 f5       	brcc	.+78     	; 0x8e4 <main+0x23a>
     896:	f9 d4       	rcall	.+2546   	; 0x128a <IsDataInPs2HostBuffer>
     898:	81 11       	cpse	r24, r1
     89a:	24 c0       	rjmp	.+72     	; 0x8e4 <main+0x23a>
     89c:	2f e7       	ldi	r18, 0x7F	; 127
     89e:	88 e3       	ldi	r24, 0x38	; 56
     8a0:	91 e0       	ldi	r25, 0x01	; 1
     8a2:	21 50       	subi	r18, 0x01	; 1
     8a4:	80 40       	sbci	r24, 0x00	; 0
     8a6:	90 40       	sbci	r25, 0x00	; 0
     8a8:	e1 f7       	brne	.-8      	; 0x8a2 <main+0x1f8>
     8aa:	00 c0       	rjmp	.+0      	; 0x8ac <main+0x202>
     8ac:	00 00       	nop
			//if (( RepeatLastSend == 0xF0 ) || ( RepeatLastSend == 0xE0 ))
			//	_delay_ms(200);
			//else
				_delay_ms(50);

			SetDeviceToHostDirection();
     8ae:	e4 de       	rcall	.-568    	; 0x678 <SetDeviceToHostDirection>

			Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , CodeArray[iKeyCodeIndex] );
     8b0:	88 89       	ldd	r24, Y+16	; 0x10
     8b2:	ea e1       	ldi	r30, 0x1A	; 26
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	ec 0f       	add	r30, r28
     8b8:	fd 1f       	adc	r31, r29
     8ba:	e8 0f       	add	r30, r24
     8bc:	f1 1d       	adc	r31, r1
     8be:	20 81       	ld	r18, Z
     8c0:	46 e0       	ldi	r20, 0x06	; 6
     8c2:	65 e0       	ldi	r22, 0x05	; 5
     8c4:	8b e2       	ldi	r24, 0x2B	; 43
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	b4 d2       	rcall	.+1384   	; 0xe32 <Write_Ps2_Byte>

			RepeatLastSend = CodeArray[iKeyCodeIndex];
     8ca:	88 89       	ldd	r24, Y+16	; 0x10
     8cc:	ea e1       	ldi	r30, 0x1A	; 26
     8ce:	f0 e0       	ldi	r31, 0x00	; 0
     8d0:	ec 0f       	add	r30, r28
     8d2:	fd 1f       	adc	r31, r29
     8d4:	e8 0f       	add	r30, r24
     8d6:	f1 1d       	adc	r31, r1
     8d8:	80 81       	ld	r24, Z
     8da:	8e 87       	std	Y+14, r24	; 0x0e

			//DirectSendData(RepeatLastSend);

			iKeyCodeIndex++;
     8dc:	88 89       	ldd	r24, Y+16	; 0x10
     8de:	8f 5f       	subi	r24, 0xFF	; 255
     8e0:	88 8b       	std	Y+16, r24	; 0x10

			ListeningtDirection();
     8e2:	d4 de       	rcall	.-600    	; 0x68c <ListeningtDirection>
									Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , StoreScanCodeState );
								}
								break;
					case 0xF3://This command is used to set the auto-repeat rate. This is the rate at which the scan code for a depressed key is sent when that key has been held depressed for a length of time exceeding a specified delay. Upon receipt of the command, the keyboard issues the acknowledge response code (FAh) and then waits for another byte of data from the host, that specifies the auto-repeat rate and also the delay before auto-repeat comes into effect,
								StoreAutoRateState = CommandReceivedByte;
								StoreAutoRateStateUpdated = 1;
     8e4:	11 e0       	ldi	r17, 0x01	; 1
     8e6:	2e c1       	rjmp	.+604    	; 0xb44 <main+0x49a>
		}

		/* Process data received from Host */
		while ( IsDataInPs2HostBuffer() )
		{
			CommandReceivedByte = GetDataFromPs2HostBuffer();
     8e8:	d9 d4       	rcall	.+2482   	; 0x129c <GetDataFromPs2HostBuffer>
     8ea:	8b 87       	std	Y+11, r24	; 0x0b

			SetDeviceToHostDirection();
     8ec:	c5 de       	rcall	.-630    	; 0x678 <SetDeviceToHostDirection>

			if ( CommandReceivedByte > 0x7F )
     8ee:	8b 85       	ldd	r24, Y+11	; 0x0b
     8f0:	88 23       	and	r24, r24
     8f2:	0c f0       	brlt	.+2      	; 0x8f6 <main+0x24c>
     8f4:	8e c0       	rjmp	.+284    	; 0xa12 <main+0x368>
			{
				switch(CommandReceivedByte)
     8f6:	8b 85       	ldd	r24, Y+11	; 0x0b
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	fc 01       	movw	r30, r24
     8fc:	ed 5e       	subi	r30, 0xED	; 237
     8fe:	f1 09       	sbc	r31, r1
     900:	e2 31       	cpi	r30, 0x12	; 18
     902:	f1 05       	cpc	r31, r1
     904:	08 f0       	brcs	.+2      	; 0x908 <main+0x25e>
     906:	16 c1       	rjmp	.+556    	; 0xb34 <main+0x48a>
     908:	e6 5e       	subi	r30, 0xE6	; 230
     90a:	ff 4f       	sbci	r31, 0xFF	; 255
     90c:	09 94       	ijmp
     90e:	af e7       	ldi	r26, 0x7F	; 127
     910:	b8 e3       	ldi	r27, 0x38	; 56
     912:	21 e0       	ldi	r18, 0x01	; 1
     914:	a1 50       	subi	r26, 0x01	; 1
     916:	b0 40       	sbci	r27, 0x00	; 0
     918:	20 40       	sbci	r18, 0x00	; 0
     91a:	e1 f7       	brne	.-8      	; 0x914 <main+0x26a>
     91c:	00 c0       	rjmp	.+0      	; 0x91e <main+0x274>
     91e:	00 00       	nop
				{
					case 0xF2:// This command is used to read the keyboard ID. Upon receipt, the keyboard responds with the acknowledge response code (FAh), followed by two bytes that constitute the keyboard's ID – ABh and 83h.
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , ACKNOWLEDGEMENT );
     920:	2a ef       	ldi	r18, 0xFA	; 250
     922:	46 e0       	ldi	r20, 0x06	; 6
     924:	65 e0       	ldi	r22, 0x05	; 5
     926:	8b e2       	ldi	r24, 0x2B	; 43
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	83 d2       	rcall	.+1286   	; 0xe32 <Write_Ps2_Byte>
     92c:	8f e7       	ldi	r24, 0x7F	; 127
     92e:	98 e3       	ldi	r25, 0x38	; 56
     930:	a1 e0       	ldi	r26, 0x01	; 1
     932:	81 50       	subi	r24, 0x01	; 1
     934:	90 40       	sbci	r25, 0x00	; 0
     936:	a0 40       	sbci	r26, 0x00	; 0
     938:	e1 f7       	brne	.-8      	; 0x932 <main+0x288>
     93a:	00 c0       	rjmp	.+0      	; 0x93c <main+0x292>
     93c:	00 00       	nop
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , KEYBOARD_ID_FIRST );
     93e:	2b ea       	ldi	r18, 0xAB	; 171
     940:	46 e0       	ldi	r20, 0x06	; 6
     942:	65 e0       	ldi	r22, 0x05	; 5
     944:	8b e2       	ldi	r24, 0x2B	; 43
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	74 d2       	rcall	.+1256   	; 0xe32 <Write_Ps2_Byte>
     94a:	bf e7       	ldi	r27, 0x7F	; 127
     94c:	28 e3       	ldi	r18, 0x38	; 56
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	b1 50       	subi	r27, 0x01	; 1
     952:	20 40       	sbci	r18, 0x00	; 0
     954:	80 40       	sbci	r24, 0x00	; 0
     956:	e1 f7       	brne	.-8      	; 0x950 <main+0x2a6>
     958:	00 c0       	rjmp	.+0      	; 0x95a <main+0x2b0>
     95a:	00 00       	nop
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , KEYBOARD_ID_SECOND );
     95c:	23 e8       	ldi	r18, 0x83	; 131
     95e:	46 e0       	ldi	r20, 0x06	; 6
     960:	65 e0       	ldi	r22, 0x05	; 5
     962:	8b e2       	ldi	r24, 0x2B	; 43
     964:	90 e0       	ldi	r25, 0x00	; 0
     966:	65 d2       	rcall	.+1226   	; 0xe32 <Write_Ps2_Byte>
								break;
     968:	e5 c0       	rjmp	.+458    	; 0xb34 <main+0x48a>
     96a:	9f e7       	ldi	r25, 0x7F	; 127
     96c:	a8 e3       	ldi	r26, 0x38	; 56
     96e:	b1 e0       	ldi	r27, 0x01	; 1
     970:	91 50       	subi	r25, 0x01	; 1
     972:	a0 40       	sbci	r26, 0x00	; 0
     974:	b0 40       	sbci	r27, 0x00	; 0
     976:	e1 f7       	brne	.-8      	; 0x970 <main+0x2c6>
     978:	00 c0       	rjmp	.+0      	; 0x97a <main+0x2d0>
     97a:	00 00       	nop
					case 0xEE://This is the echo command. Upon receipt, the keyboard transmits the echo response code (EEh).
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , ECHO_RESPONSE );
     97c:	2e ee       	ldi	r18, 0xEE	; 238
     97e:	46 e0       	ldi	r20, 0x06	; 6
     980:	65 e0       	ldi	r22, 0x05	; 5
     982:	8b e2       	ldi	r24, 0x2B	; 43
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	55 d2       	rcall	.+1194   	; 0xe32 <Write_Ps2_Byte>
								break;
     988:	d5 c0       	rjmp	.+426    	; 0xb34 <main+0x48a>
     98a:	2f e7       	ldi	r18, 0x7F	; 127
     98c:	88 e3       	ldi	r24, 0x38	; 56
     98e:	91 e0       	ldi	r25, 0x01	; 1
     990:	21 50       	subi	r18, 0x01	; 1
     992:	80 40       	sbci	r24, 0x00	; 0
     994:	90 40       	sbci	r25, 0x00	; 0
     996:	e1 f7       	brne	.-8      	; 0x990 <main+0x2e6>
     998:	00 c0       	rjmp	.+0      	; 0x99a <main+0x2f0>
     99a:	00 00       	nop
					case 0xED://This command is used to turn the keyboard's LED indicators ON or OFF
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , ACKNOWLEDGEMENT );
     99c:	2a ef       	ldi	r18, 0xFA	; 250
     99e:	46 e0       	ldi	r20, 0x06	; 6
     9a0:	65 e0       	ldi	r22, 0x05	; 5
     9a2:	8b e2       	ldi	r24, 0x2B	; 43
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	45 d2       	rcall	.+1162   	; 0xe32 <Write_Ps2_Byte>
								break;
     9a8:	c5 c0       	rjmp	.+394    	; 0xb34 <main+0x48a>
     9aa:	af e7       	ldi	r26, 0x7F	; 127
     9ac:	b8 e3       	ldi	r27, 0x38	; 56
     9ae:	21 e0       	ldi	r18, 0x01	; 1
     9b0:	a1 50       	subi	r26, 0x01	; 1
     9b2:	b0 40       	sbci	r27, 0x00	; 0
     9b4:	20 40       	sbci	r18, 0x00	; 0
     9b6:	e1 f7       	brne	.-8      	; 0x9b0 <main+0x306>
     9b8:	00 c0       	rjmp	.+0      	; 0x9ba <main+0x310>
     9ba:	00 00       	nop
					case 0xF0://This command is used to select the scan code set to be used for the keyboard. Every key on the keyboard has a scan code associated with it and it is this code that is sent to the host CPU when the key is pressed. The keyboard sends an acknowledgement (response code FAh) and then waits for another byte of data from the host, that specifies the particular scan code set to be used.
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , ACKNOWLEDGEMENT );
     9bc:	2a ef       	ldi	r18, 0xFA	; 250
     9be:	46 e0       	ldi	r20, 0x06	; 6
     9c0:	65 e0       	ldi	r22, 0x05	; 5
     9c2:	8b e2       	ldi	r24, 0x2B	; 43
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	35 d2       	rcall	.+1130   	; 0xe32 <Write_Ps2_Byte>
								break;
     9c8:	b5 c0       	rjmp	.+362    	; 0xb34 <main+0x48a>
     9ca:	8f e7       	ldi	r24, 0x7F	; 127
     9cc:	98 e3       	ldi	r25, 0x38	; 56
     9ce:	a1 e0       	ldi	r26, 0x01	; 1
     9d0:	81 50       	subi	r24, 0x01	; 1
     9d2:	90 40       	sbci	r25, 0x00	; 0
     9d4:	a0 40       	sbci	r26, 0x00	; 0
     9d6:	e1 f7       	brne	.-8      	; 0x9d0 <main+0x326>
     9d8:	00 c0       	rjmp	.+0      	; 0x9da <main+0x330>
     9da:	00 00       	nop
					case 0xF3://This command is used to set the auto-repeat rate. This is the rate at which the scan code for a depressed key is sent when that key has been held depressed for a length of time exceeding a specified delay. Upon receipt of the command, the keyboard issues the acknowledge response code (FAh) and then waits for another byte of data from the host, that specifies the auto-repeat rate and also the delay before auto-repeat comes into effect,
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , ACKNOWLEDGEMENT );
     9dc:	2a ef       	ldi	r18, 0xFA	; 250
     9de:	46 e0       	ldi	r20, 0x06	; 6
     9e0:	65 e0       	ldi	r22, 0x05	; 5
     9e2:	8b e2       	ldi	r24, 0x2B	; 43
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	25 d2       	rcall	.+1098   	; 0xe32 <Write_Ps2_Byte>
								break;
     9e8:	a5 c0       	rjmp	.+330    	; 0xb34 <main+0x48a>
					case 0xF4:// This command is used to enable the keyboard. Upon receipt of the command, the keyboard's output buffer is flushed and keyboard scanning (of the PSDATA and PSCLK lines) is enabled. The keyboard responds by sending the acknowledgement code (FAh).
								StoreEnableStateUpdated = 1;
     9ea:	18 8f       	std	Y+24, r17	; 0x18
								break;
     9ec:	a3 c0       	rjmp	.+326    	; 0xb34 <main+0x48a>
					case 0xF5://This command is used to disable the keyboard. Upon receipt of the command, the keyboard is reset. The keyboard issues the acknowledgement code (FAh) and then keyboard scanning (of the PSDATA and PSCLK lines) is disabled. The keyboard remains in this state, waiting for another command from the host CPU.
								StoreDisableStateUpdated = 1;
     9ee:	19 8f       	std	Y+25, r17	; 0x19
								break;
     9f0:	a1 c0       	rjmp	.+322    	; 0xb34 <main+0x48a>
     9f2:	bf e7       	ldi	r27, 0x7F	; 127
     9f4:	28 e3       	ldi	r18, 0x38	; 56
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	b1 50       	subi	r27, 0x01	; 1
     9fa:	20 40       	sbci	r18, 0x00	; 0
     9fc:	80 40       	sbci	r24, 0x00	; 0
     9fe:	e1 f7       	brne	.-8      	; 0x9f8 <main+0x34e>
     a00:	00 c0       	rjmp	.+0      	; 0xa02 <main+0x358>
     a02:	00 00       	nop
					case 0xFE://This is the resend command and is used when the host requires the keyboard to retransmit the last byte of data sent. Upon receipt, the keyboard responds with the acknowledge response code (FAh), then proceeds to transmit the previously sent byte of data.
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , RepeatLastSend );
     a04:	2e 85       	ldd	r18, Y+14	; 0x0e
     a06:	46 e0       	ldi	r20, 0x06	; 6
     a08:	65 e0       	ldi	r22, 0x05	; 5
     a0a:	8b e2       	ldi	r24, 0x2B	; 43
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	11 d2       	rcall	.+1058   	; 0xe32 <Write_Ps2_Byte>
								break;
     a10:	91 c0       	rjmp	.+290    	; 0xb34 <main+0x48a>
								break;
				}
			}
			else
			{
				switch(PreviousCommandByte)
     a12:	8c 85       	ldd	r24, Y+12	; 0x0c
     a14:	90 e0       	ldi	r25, 0x00	; 0
     a16:	fc 01       	movw	r30, r24
     a18:	ed 5e       	subi	r30, 0xED	; 237
     a1a:	f1 09       	sbc	r31, r1
     a1c:	e3 31       	cpi	r30, 0x13	; 19
     a1e:	f1 05       	cpc	r31, r1
     a20:	08 f0       	brcs	.+2      	; 0xa24 <main+0x37a>
     a22:	82 c0       	rjmp	.+260    	; 0xb28 <main+0x47e>
     a24:	e4 5d       	subi	r30, 0xD4	; 212
     a26:	ff 4f       	sbci	r31, 0xFF	; 255
     a28:	09 94       	ijmp
     a2a:	9f e7       	ldi	r25, 0x7F	; 127
     a2c:	a8 e3       	ldi	r26, 0x38	; 56
     a2e:	b1 e0       	ldi	r27, 0x01	; 1
     a30:	91 50       	subi	r25, 0x01	; 1
     a32:	a0 40       	sbci	r26, 0x00	; 0
     a34:	b0 40       	sbci	r27, 0x00	; 0
     a36:	e1 f7       	brne	.-8      	; 0xa30 <main+0x386>
     a38:	00 c0       	rjmp	.+0      	; 0xa3a <main+0x390>
     a3a:	00 00       	nop
				{
					case 0xF2:// This command is used to read the keyboard ID. Upon receipt, the keyboard responds with the acknowledge response code (FAh), followed by two bytes that constitute the keyboard's ID – ABh and 83h.
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     a3c:	2f ef       	ldi	r18, 0xFF	; 255
     a3e:	46 e0       	ldi	r20, 0x06	; 6
     a40:	65 e0       	ldi	r22, 0x05	; 5
     a42:	8b e2       	ldi	r24, 0x2B	; 43
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	f5 d1       	rcall	.+1002   	; 0xe32 <Write_Ps2_Byte>
								break;
     a48:	75 c0       	rjmp	.+234    	; 0xb34 <main+0x48a>
     a4a:	2f e7       	ldi	r18, 0x7F	; 127
     a4c:	88 e3       	ldi	r24, 0x38	; 56
     a4e:	91 e0       	ldi	r25, 0x01	; 1
     a50:	21 50       	subi	r18, 0x01	; 1
     a52:	80 40       	sbci	r24, 0x00	; 0
     a54:	90 40       	sbci	r25, 0x00	; 0
     a56:	e1 f7       	brne	.-8      	; 0xa50 <main+0x3a6>
     a58:	00 c0       	rjmp	.+0      	; 0xa5a <main+0x3b0>
     a5a:	00 00       	nop
					case 0xEE://This is the echo command. Upon receipt, the keyboard transmits the echo response code (EEh).
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     a5c:	2f ef       	ldi	r18, 0xFF	; 255
     a5e:	46 e0       	ldi	r20, 0x06	; 6
     a60:	65 e0       	ldi	r22, 0x05	; 5
     a62:	8b e2       	ldi	r24, 0x2B	; 43
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	e5 d1       	rcall	.+970    	; 0xe32 <Write_Ps2_Byte>
								break;
     a68:	65 c0       	rjmp	.+202    	; 0xb34 <main+0x48a>
					case 0xED://This command is used to turn the keyboard's LED indicators ON or OFF
								StoreLedsState = CommandReceivedByte;
     a6a:	8b 85       	ldd	r24, Y+11	; 0x0b
     a6c:	8a 8b       	std	Y+18, r24	; 0x12
								StoreLedsStateUpdated = 1;
     a6e:	1b 8b       	std	Y+19, r17	; 0x13
								break;
     a70:	61 c0       	rjmp	.+194    	; 0xb34 <main+0x48a>
					case 0xF0://This command is used to select the scan code set to be used for the keyboard. Every key on the keyboard has a scan code associated with it and it is this code that is sent to the host CPU when the key is pressed. The keyboard sends an acknowledgement (response code FAh) and then waits for another byte of data from the host, that specifies the particular scan code set to be used.
								if ( CommandReceivedByte & 0x03 )
     a72:	8b 85       	ldd	r24, Y+11	; 0x0b
     a74:	83 70       	andi	r24, 0x03	; 3
     a76:	21 f0       	breq	.+8      	; 0xa80 <main+0x3d6>
								{
									StoreScanCodeState = CommandReceivedByte;
     a78:	8b 85       	ldd	r24, Y+11	; 0x0b
     a7a:	8c 8b       	std	Y+20, r24	; 0x14
									StoreScanCodeStateUpdated = 1;
     a7c:	1d 8b       	std	Y+21, r17	; 0x15
     a7e:	5a c0       	rjmp	.+180    	; 0xb34 <main+0x48a>
     a80:	af e7       	ldi	r26, 0x7F	; 127
     a82:	b8 e3       	ldi	r27, 0x38	; 56
     a84:	21 e0       	ldi	r18, 0x01	; 1
     a86:	a1 50       	subi	r26, 0x01	; 1
     a88:	b0 40       	sbci	r27, 0x00	; 0
     a8a:	20 40       	sbci	r18, 0x00	; 0
     a8c:	e1 f7       	brne	.-8      	; 0xa86 <main+0x3dc>
     a8e:	00 c0       	rjmp	.+0      	; 0xa90 <main+0x3e6>
     a90:	00 00       	nop
								}
								else
								{
									_delay_ms(50);
									Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , StoreScanCodeState );
     a92:	2c 89       	ldd	r18, Y+20	; 0x14
     a94:	46 e0       	ldi	r20, 0x06	; 6
     a96:	65 e0       	ldi	r22, 0x05	; 5
     a98:	8b e2       	ldi	r24, 0x2B	; 43
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	ca d1       	rcall	.+916    	; 0xe32 <Write_Ps2_Byte>
     a9e:	4a c0       	rjmp	.+148    	; 0xb34 <main+0x48a>
								}
								break;
					case 0xF3://This command is used to set the auto-repeat rate. This is the rate at which the scan code for a depressed key is sent when that key has been held depressed for a length of time exceeding a specified delay. Upon receipt of the command, the keyboard issues the acknowledge response code (FAh) and then waits for another byte of data from the host, that specifies the auto-repeat rate and also the delay before auto-repeat comes into effect,
								StoreAutoRateState = CommandReceivedByte;
     aa0:	8b 85       	ldd	r24, Y+11	; 0x0b
     aa2:	8e 8b       	std	Y+22, r24	; 0x16
								StoreAutoRateStateUpdated = 1;
     aa4:	1f 8b       	std	Y+23, r17	; 0x17
								break;
     aa6:	46 c0       	rjmp	.+140    	; 0xb34 <main+0x48a>
     aa8:	8f e7       	ldi	r24, 0x7F	; 127
     aaa:	98 e3       	ldi	r25, 0x38	; 56
     aac:	a1 e0       	ldi	r26, 0x01	; 1
     aae:	81 50       	subi	r24, 0x01	; 1
     ab0:	90 40       	sbci	r25, 0x00	; 0
     ab2:	a0 40       	sbci	r26, 0x00	; 0
     ab4:	e1 f7       	brne	.-8      	; 0xaae <main+0x404>
     ab6:	00 c0       	rjmp	.+0      	; 0xab8 <main+0x40e>
     ab8:	00 00       	nop
					case 0xF4:// This command is used to enable the keyboard. Upon receipt of the command, the keyboard's output buffer is flushed and keyboard scanning (of the PSDATA and PSCLK lines) is enabled. The keyboard responds by sending the acknowledgement code (FAh).
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     aba:	2f ef       	ldi	r18, 0xFF	; 255
     abc:	46 e0       	ldi	r20, 0x06	; 6
     abe:	65 e0       	ldi	r22, 0x05	; 5
     ac0:	8b e2       	ldi	r24, 0x2B	; 43
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	b6 d1       	rcall	.+876    	; 0xe32 <Write_Ps2_Byte>
								break;
     ac6:	36 c0       	rjmp	.+108    	; 0xb34 <main+0x48a>
     ac8:	bf e7       	ldi	r27, 0x7F	; 127
     aca:	28 e3       	ldi	r18, 0x38	; 56
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	b1 50       	subi	r27, 0x01	; 1
     ad0:	20 40       	sbci	r18, 0x00	; 0
     ad2:	80 40       	sbci	r24, 0x00	; 0
     ad4:	e1 f7       	brne	.-8      	; 0xace <main+0x424>
     ad6:	00 c0       	rjmp	.+0      	; 0xad8 <main+0x42e>
     ad8:	00 00       	nop
					case 0xF5://This command is used to disable the keyboard. Upon receipt of the command, the keyboard is reset. The keyboard issues the acknowledgement code (FAh) and then keyboard scanning (of the PSDATA and PSCLK lines) is disabled. The keyboard remains in this state, waiting for another command from the host CPU.
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     ada:	2f ef       	ldi	r18, 0xFF	; 255
     adc:	46 e0       	ldi	r20, 0x06	; 6
     ade:	65 e0       	ldi	r22, 0x05	; 5
     ae0:	8b e2       	ldi	r24, 0x2B	; 43
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	a6 d1       	rcall	.+844    	; 0xe32 <Write_Ps2_Byte>
								break;
     ae6:	26 c0       	rjmp	.+76     	; 0xb34 <main+0x48a>
     ae8:	9f e7       	ldi	r25, 0x7F	; 127
     aea:	a8 e3       	ldi	r26, 0x38	; 56
     aec:	b1 e0       	ldi	r27, 0x01	; 1
     aee:	91 50       	subi	r25, 0x01	; 1
     af0:	a0 40       	sbci	r26, 0x00	; 0
     af2:	b0 40       	sbci	r27, 0x00	; 0
     af4:	e1 f7       	brne	.-8      	; 0xaee <main+0x444>
     af6:	00 c0       	rjmp	.+0      	; 0xaf8 <main+0x44e>
     af8:	00 00       	nop
					case 0xFE://This is the resend command and is used when the host requires the keyboard to retransmit the last byte of data sent. Upon receipt, the keyboard responds with the acknowledge response code (FAh), then proceeds to transmit the previously sent byte of data.
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     afa:	2f ef       	ldi	r18, 0xFF	; 255
     afc:	46 e0       	ldi	r20, 0x06	; 6
     afe:	65 e0       	ldi	r22, 0x05	; 5
     b00:	8b e2       	ldi	r24, 0x2B	; 43
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	96 d1       	rcall	.+812    	; 0xe32 <Write_Ps2_Byte>
								break;
     b06:	16 c0       	rjmp	.+44     	; 0xb34 <main+0x48a>
     b08:	2f e7       	ldi	r18, 0x7F	; 127
     b0a:	88 e3       	ldi	r24, 0x38	; 56
     b0c:	91 e0       	ldi	r25, 0x01	; 1
     b0e:	21 50       	subi	r18, 0x01	; 1
     b10:	80 40       	sbci	r24, 0x00	; 0
     b12:	90 40       	sbci	r25, 0x00	; 0
     b14:	e1 f7       	brne	.-8      	; 0xb0e <main+0x464>
     b16:	00 c0       	rjmp	.+0      	; 0xb18 <main+0x46e>
     b18:	00 00       	nop
					case 0xFF://This command is used to reset the mouse. Upon receipt of the command, the mouse sends the acknowledge response code (FAh). The mouse is reset and subsequently performs its power-on Basic Assurance Test (BAT). During this test, default values are loaded for the sampling rate, resolution and scaling, and data reporting is disabled. Depending on the result of the test, the mouse will either send the 'Passed' code (AAh) or the 'Failed' code (FCh).
								_delay_ms(50);
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     b1a:	2f ef       	ldi	r18, 0xFF	; 255
     b1c:	46 e0       	ldi	r20, 0x06	; 6
     b1e:	65 e0       	ldi	r22, 0x05	; 5
     b20:	8b e2       	ldi	r24, 0x2B	; 43
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	86 d1       	rcall	.+780    	; 0xe32 <Write_Ps2_Byte>
								break;
     b26:	06 c0       	rjmp	.+12     	; 0xb34 <main+0x48a>
					default:
								Write_Ps2_Byte( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , DEVICE_FEEDBACK_ERROR );
     b28:	2f ef       	ldi	r18, 0xFF	; 255
     b2a:	46 e0       	ldi	r20, 0x06	; 6
     b2c:	65 e0       	ldi	r22, 0x05	; 5
     b2e:	8b e2       	ldi	r24, 0x2B	; 43
     b30:	90 e0       	ldi	r25, 0x00	; 0
     b32:	7f d1       	rcall	.+766    	; 0xe32 <Write_Ps2_Byte>
								break;
				}
			}

			ListeningtDirection();
     b34:	ab dd       	rcall	.-1194   	; 0x68c <ListeningtDirection>

			PreviousCommandByte = CommandReceivedByte;
     b36:	8b 85       	ldd	r24, Y+11	; 0x0b
     b38:	8c 87       	std	Y+12, r24	; 0x0c

			Set_Port_Bit( &PORTC , YELLOW_LED_BIT , LED_ON );							// Yellow LED ON ( Rs232 Sending )
     b3a:	40 e0       	ldi	r20, 0x00	; 0
     b3c:	62 e0       	ldi	r22, 0x02	; 2
     b3e:	88 e2       	ldi	r24, 0x28	; 40
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	79 dd       	rcall	.-1294   	; 0x636 <Set_Port_Bit>

			ListeningtDirection();
		}

		/* Process data received from Host */
		while ( IsDataInPs2HostBuffer() )
     b44:	a2 d3       	rcall	.+1860   	; 0x128a <IsDataInPs2HostBuffer>
     b46:	81 11       	cpse	r24, r1
     b48:	cf ce       	rjmp	.-610    	; 0x8e8 <main+0x23e>
     b4a:	1b ce       	rjmp	.-970    	; 0x782 <main+0xd8>

00000b4c <Sniffer_PS2_Byte>:
#define		CLOCK_PERIOD_uSec			10UL
#define		DOUBLE_CLOCK_PERIOD_uSec	(CLOCK_PERIOD_uSec * 2UL)
#define		HALF_CLOCK_PERIOD_uSec		(CLOCK_PERIOD_uSec / 2UL)

unsigned char Sniffer_PS2_Byte( volatile uint8_t *PORT_ADDRESS , unsigned char ucClockBitNumber , unsigned char ucDataBitNumber , unsigned char *pucDataByte )
{
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	cf 93       	push	r28
     b52:	df 93       	push	r29
     b54:	cd b7       	in	r28, 0x3d	; 61
     b56:	de b7       	in	r29, 0x3e	; 62
     b58:	62 97       	sbiw	r28, 0x12	; 18
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	de bf       	out	0x3e, r29	; 62
     b60:	0f be       	out	0x3f, r0	; 63
     b62:	cd bf       	out	0x3d, r28	; 61
     b64:	dc 01       	movw	r26, r24
	volatile unsigned char			index												=	0;
     b66:	19 82       	std	Y+1, r1	; 0x01

	volatile unsigned char			ClockBit											=	0,
     b68:	1a 82       	std	Y+2, r1	; 0x02
										DataBit												=	0;
     b6a:	1b 82       	std	Y+3, r1	; 0x03

	volatile unsigned char			BitIndex											=	0,
     b6c:	1c 82       	std	Y+4, r1	; 0x04
										BitFound											=	0;
     b6e:	1d 82       	std	Y+5, r1	; 0x05

	volatile unsigned char			vReceiveBuffer[10]									=	{0},
     b70:	8e 01       	movw	r16, r28
     b72:	0a 5f       	subi	r16, 0xFA	; 250
     b74:	1f 4f       	sbci	r17, 0xFF	; 255
     b76:	8a e0       	ldi	r24, 0x0A	; 10
     b78:	f8 01       	movw	r30, r16
     b7a:	11 92       	st	Z+, r1
     b7c:	8a 95       	dec	r24
     b7e:	e9 f7       	brne	.-6      	; 0xb7a <Sniffer_PS2_Byte+0x2e>
										ParityBitError										=	0,
     b80:	18 8a       	std	Y+16, r1	; 0x10
										PortReadData										=	0,
     b82:	19 8a       	std	Y+17, r1	; 0x11
										ReceivedByte										=	0;
     b84:	1a 8a       	std	Y+18, r1	; 0x12

	for ( BitIndex = 0; BitIndex < 10 ; BitIndex++ )
     b86:	1c 82       	std	Y+4, r1	; 0x04
     b88:	8c 81       	ldd	r24, Y+4	; 0x04
     b8a:	8a 30       	cpi	r24, 0x0A	; 10
     b8c:	c8 f5       	brcc	.+114    	; 0xc00 <Sniffer_PS2_Byte+0xb4>
					continue;
				else
					break;
			}

			BitFound = 1;
     b8e:	51 e0       	ldi	r21, 0x01	; 1
										PortReadData										=	0,
										ReceivedByte										=	0;

	for ( BitIndex = 0; BitIndex < 10 ; BitIndex++ )
	{
		BitFound = 0;
     b90:	1d 82       	std	Y+5, r1	; 0x05

		for( index = 0 ; index < 40 ; index++ )
     b92:	19 82       	std	Y+1, r1	; 0x01
     b94:	89 81       	ldd	r24, Y+1	; 0x01
     b96:	88 32       	cpi	r24, 0x28	; 40
     b98:	68 f5       	brcc	.+90     	; 0xbf4 <Sniffer_PS2_Byte+0xa8>
		{
			PortReadData = *PORT_ADDRESS;
     b9a:	8c 91       	ld	r24, X
     b9c:	89 8b       	std	Y+17, r24	; 0x11

			ClockBit = ( PortReadData >> ucClockBitNumber ) & 0x01;
     b9e:	e9 89       	ldd	r30, Y+17	; 0x11
     ba0:	f0 e0       	ldi	r31, 0x00	; 0
     ba2:	06 2e       	mov	r0, r22
     ba4:	02 c0       	rjmp	.+4      	; 0xbaa <Sniffer_PS2_Byte+0x5e>
     ba6:	f5 95       	asr	r31
     ba8:	e7 95       	ror	r30
     baa:	0a 94       	dec	r0
     bac:	e2 f7       	brpl	.-8      	; 0xba6 <Sniffer_PS2_Byte+0x5a>
     bae:	e1 70       	andi	r30, 0x01	; 1
     bb0:	ea 83       	std	Y+2, r30	; 0x02
			DataBit = ( PortReadData >> ucDataBitNumber ) & 0x01;
     bb2:	e9 89       	ldd	r30, Y+17	; 0x11
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	04 2e       	mov	r0, r20
     bb8:	02 c0       	rjmp	.+4      	; 0xbbe <Sniffer_PS2_Byte+0x72>
     bba:	f5 95       	asr	r31
     bbc:	e7 95       	ror	r30
     bbe:	0a 94       	dec	r0
     bc0:	e2 f7       	brpl	.-8      	; 0xbba <Sniffer_PS2_Byte+0x6e>
     bc2:	e1 70       	andi	r30, 0x01	; 1
     bc4:	eb 83       	std	Y+3, r30	; 0x03

			if ( ClockBit == 1 )
     bc6:	8a 81       	ldd	r24, Y+2	; 0x02
     bc8:	81 30       	cpi	r24, 0x01	; 1
     bca:	21 f4       	brne	.+8      	; 0xbd4 <Sniffer_PS2_Byte+0x88>
			{
				if ( BitFound == 0 )
     bcc:	8d 81       	ldd	r24, Y+5	; 0x05
     bce:	88 23       	and	r24, r24
     bd0:	59 f0       	breq	.+22     	; 0xbe8 <Sniffer_PS2_Byte+0x9c>
     bd2:	10 c0       	rjmp	.+32     	; 0xbf4 <Sniffer_PS2_Byte+0xa8>
					continue;
				else
					break;
			}

			BitFound = 1;
     bd4:	5d 83       	std	Y+5, r21	; 0x05
			vReceiveBuffer[BitIndex] = DataBit;
     bd6:	9c 81       	ldd	r25, Y+4	; 0x04
     bd8:	8b 81       	ldd	r24, Y+3	; 0x03
     bda:	e6 e0       	ldi	r30, 0x06	; 6
     bdc:	f0 e0       	ldi	r31, 0x00	; 0
     bde:	ec 0f       	add	r30, r28
     be0:	fd 1f       	adc	r31, r29
     be2:	e9 0f       	add	r30, r25
     be4:	f1 1d       	adc	r31, r1
     be6:	80 83       	st	Z, r24

	for ( BitIndex = 0; BitIndex < 10 ; BitIndex++ )
	{
		BitFound = 0;

		for( index = 0 ; index < 40 ; index++ )
     be8:	89 81       	ldd	r24, Y+1	; 0x01
     bea:	8f 5f       	subi	r24, 0xFF	; 255
     bec:	89 83       	std	Y+1, r24	; 0x01
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	88 32       	cpi	r24, 0x28	; 40
     bf2:	98 f2       	brcs	.-90     	; 0xb9a <Sniffer_PS2_Byte+0x4e>
	volatile unsigned char			vReceiveBuffer[10]									=	{0},
										ParityBitError										=	0,
										PortReadData										=	0,
										ReceivedByte										=	0;

	for ( BitIndex = 0; BitIndex < 10 ; BitIndex++ )
     bf4:	8c 81       	ldd	r24, Y+4	; 0x04
     bf6:	8f 5f       	subi	r24, 0xFF	; 255
     bf8:	8c 83       	std	Y+4, r24	; 0x04
     bfa:	8c 81       	ldd	r24, Y+4	; 0x04
     bfc:	8a 30       	cpi	r24, 0x0A	; 10
     bfe:	40 f2       	brcs	.-112    	; 0xb90 <Sniffer_PS2_Byte+0x44>
			BitFound = 1;
			vReceiveBuffer[BitIndex] = DataBit;
		};
	}

	ParityBitError = 1;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	88 8b       	std	Y+16, r24	; 0x10

	for( BitIndex = 0 ; BitIndex < 10 ; BitIndex++ )
     c04:	1c 82       	std	Y+4, r1	; 0x04
     c06:	8c 81       	ldd	r24, Y+4	; 0x04
     c08:	8a 30       	cpi	r24, 0x0A	; 10
     c0a:	b8 f4       	brcc	.+46     	; 0xc3a <Sniffer_PS2_Byte+0xee>
	{
		if ( vReceiveBuffer[BitIndex] )
			ParityBitError = !ParityBitError;
     c0c:	41 e0       	ldi	r20, 0x01	; 1
     c0e:	50 e0       	ldi	r21, 0x00	; 0

	ParityBitError = 1;

	for( BitIndex = 0 ; BitIndex < 10 ; BitIndex++ )
	{
		if ( vReceiveBuffer[BitIndex] )
     c10:	8c 81       	ldd	r24, Y+4	; 0x04
     c12:	e6 e0       	ldi	r30, 0x06	; 6
     c14:	f0 e0       	ldi	r31, 0x00	; 0
     c16:	ec 0f       	add	r30, r28
     c18:	fd 1f       	adc	r31, r29
     c1a:	e8 0f       	add	r30, r24
     c1c:	f1 1d       	adc	r31, r1
     c1e:	80 81       	ld	r24, Z
     c20:	88 23       	and	r24, r24
     c22:	29 f0       	breq	.+10     	; 0xc2e <Sniffer_PS2_Byte+0xe2>
			ParityBitError = !ParityBitError;
     c24:	98 89       	ldd	r25, Y+16	; 0x10
     c26:	84 2f       	mov	r24, r20
     c28:	91 11       	cpse	r25, r1
     c2a:	85 2f       	mov	r24, r21
     c2c:	88 8b       	std	Y+16, r24	; 0x10
		};
	}

	ParityBitError = 1;

	for( BitIndex = 0 ; BitIndex < 10 ; BitIndex++ )
     c2e:	8c 81       	ldd	r24, Y+4	; 0x04
     c30:	8f 5f       	subi	r24, 0xFF	; 255
     c32:	8c 83       	std	Y+4, r24	; 0x04
     c34:	8c 81       	ldd	r24, Y+4	; 0x04
     c36:	8a 30       	cpi	r24, 0x0A	; 10
     c38:	58 f3       	brcs	.-42     	; 0xc10 <Sniffer_PS2_Byte+0xc4>
	{
		if ( vReceiveBuffer[BitIndex] )
			ParityBitError = !ParityBitError;
	}

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
     c3a:	1c 82       	std	Y+4, r1	; 0x04
     c3c:	8c 81       	ldd	r24, Y+4	; 0x04
     c3e:	88 30       	cpi	r24, 0x08	; 8
     c40:	f8 f4       	brcc	.+62     	; 0xc80 <Sniffer_PS2_Byte+0x134>
		if ( vReceiveBuffer[BitIndex+1] )
			ReceivedByte |= ( 1 << BitIndex );
     c42:	41 e0       	ldi	r20, 0x01	; 1
     c44:	50 e0       	ldi	r21, 0x00	; 0
		if ( vReceiveBuffer[BitIndex] )
			ParityBitError = !ParityBitError;
	}

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
		if ( vReceiveBuffer[BitIndex+1] )
     c46:	ec 81       	ldd	r30, Y+4	; 0x04
     c48:	f0 e0       	ldi	r31, 0x00	; 0
     c4a:	31 96       	adiw	r30, 0x01	; 1
     c4c:	86 e0       	ldi	r24, 0x06	; 6
     c4e:	90 e0       	ldi	r25, 0x00	; 0
     c50:	8c 0f       	add	r24, r28
     c52:	9d 1f       	adc	r25, r29
     c54:	e8 0f       	add	r30, r24
     c56:	f9 1f       	adc	r31, r25
     c58:	80 81       	ld	r24, Z
     c5a:	88 23       	and	r24, r24
     c5c:	59 f0       	breq	.+22     	; 0xc74 <Sniffer_PS2_Byte+0x128>
			ReceivedByte |= ( 1 << BitIndex );
     c5e:	8c 81       	ldd	r24, Y+4	; 0x04
     c60:	6a 89       	ldd	r22, Y+18	; 0x12
     c62:	fa 01       	movw	r30, r20
     c64:	02 c0       	rjmp	.+4      	; 0xc6a <Sniffer_PS2_Byte+0x11e>
     c66:	ee 0f       	add	r30, r30
     c68:	ff 1f       	adc	r31, r31
     c6a:	8a 95       	dec	r24
     c6c:	e2 f7       	brpl	.-8      	; 0xc66 <Sniffer_PS2_Byte+0x11a>
     c6e:	cf 01       	movw	r24, r30
     c70:	86 2b       	or	r24, r22
     c72:	8a 8b       	std	Y+18, r24	; 0x12
	{
		if ( vReceiveBuffer[BitIndex] )
			ParityBitError = !ParityBitError;
	}

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
     c74:	8c 81       	ldd	r24, Y+4	; 0x04
     c76:	8f 5f       	subi	r24, 0xFF	; 255
     c78:	8c 83       	std	Y+4, r24	; 0x04
     c7a:	8c 81       	ldd	r24, Y+4	; 0x04
     c7c:	88 30       	cpi	r24, 0x08	; 8
     c7e:	18 f3       	brcs	.-58     	; 0xc46 <Sniffer_PS2_Byte+0xfa>
		if ( vReceiveBuffer[BitIndex+1] )
			ReceivedByte |= ( 1 << BitIndex );

	*pucDataByte = ReceivedByte;
     c80:	8a 89       	ldd	r24, Y+18	; 0x12
     c82:	f9 01       	movw	r30, r18
     c84:	80 83       	st	Z, r24

	return ParityBitError;
     c86:	88 89       	ldd	r24, Y+16	; 0x10
}
     c88:	62 96       	adiw	r28, 0x12	; 18
     c8a:	0f b6       	in	r0, 0x3f	; 63
     c8c:	f8 94       	cli
     c8e:	de bf       	out	0x3e, r29	; 62
     c90:	0f be       	out	0x3f, r0	; 63
     c92:	cd bf       	out	0x3d, r28	; 61
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	1f 91       	pop	r17
     c9a:	0f 91       	pop	r16
     c9c:	08 95       	ret

00000c9e <Read_Ps2_Byte>:

unsigned char Read_Ps2_Byte( volatile uint8_t *READ_PORT_ADDRESS , volatile uint8_t *WRITE_PORT_ADDRESS ,unsigned char ucClockBitNumber , unsigned char ucDataBitNumber , volatile unsigned char *pucDataByte )
{
     c9e:	6f 92       	push	r6
     ca0:	7f 92       	push	r7
     ca2:	8f 92       	push	r8
     ca4:	9f 92       	push	r9
     ca6:	af 92       	push	r10
     ca8:	bf 92       	push	r11
     caa:	cf 92       	push	r12
     cac:	df 92       	push	r13
     cae:	ef 92       	push	r14
     cb0:	ff 92       	push	r15
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	cd b7       	in	r28, 0x3d	; 61
     cbc:	de b7       	in	r29, 0x3e	; 62
     cbe:	2f 97       	sbiw	r28, 0x0f	; 15
     cc0:	0f b6       	in	r0, 0x3f	; 63
     cc2:	f8 94       	cli
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	0f be       	out	0x3f, r0	; 63
     cc8:	cd bf       	out	0x3d, r28	; 61
     cca:	6c 01       	movw	r12, r24
     ccc:	7b 01       	movw	r14, r22
     cce:	94 2e       	mov	r9, r20
     cd0:	82 2e       	mov	r8, r18
	volatile unsigned char			DataBit												=	0;
     cd2:	19 82       	std	Y+1, r1	; 0x01

	volatile unsigned char			BitIndex											=	0;
     cd4:	1a 82       	std	Y+2, r1	; 0x02

	volatile unsigned char			vReceiveBuffer[11]									=	{0},
     cd6:	fe 01       	movw	r30, r28
     cd8:	33 96       	adiw	r30, 0x03	; 3
     cda:	8b e0       	ldi	r24, 0x0B	; 11
     cdc:	df 01       	movw	r26, r30
     cde:	1d 92       	st	X+, r1
     ce0:	8a 95       	dec	r24
     ce2:	e9 f7       	brne	.-6      	; 0xcde <Read_Ps2_Byte+0x40>
										ParityBitError										=	0,
     ce4:	1e 86       	std	Y+14, r1	; 0x0e
										ReceivedByte										=	0;
     ce6:	1f 86       	std	Y+15, r1	; 0x0f

	ParityBitError = 1;
     ce8:	81 e0       	ldi	r24, 0x01	; 1
     cea:	8e 87       	std	Y+14, r24	; 0x0e

	for( BitIndex = 0 ; BitIndex < 10 ; BitIndex++ )
     cec:	1a 82       	std	Y+2, r1	; 0x02
     cee:	8a 81       	ldd	r24, Y+2	; 0x02
     cf0:	8a 30       	cpi	r24, 0x0A	; 10
     cf2:	08 f0       	brcs	.+2      	; 0xcf6 <Read_Ps2_Byte+0x58>
     cf4:	4b c0       	rjmp	.+150    	; 0xd8c <Read_Ps2_Byte+0xee>
		DataBit = ( *READ_PORT_ADDRESS >> ucDataBitNumber ) & 0x01;
		vReceiveBuffer[BitIndex] = DataBit;

		if ( DataBit > 0 )
		{
			ParityBitError = !ParityBitError;
     cf6:	77 24       	eor	r7, r7
     cf8:	73 94       	inc	r7

			if (( BitIndex > 0 ) && ( BitIndex < 9 ))
				ReceivedByte |= ( 1 << ( BitIndex - 1 ));
     cfa:	aa 24       	eor	r10, r10
     cfc:	a3 94       	inc	r10
     cfe:	b1 2c       	mov	r11, r1
		DataBit = ( *READ_PORT_ADDRESS >> ucDataBitNumber ) & 0x01;
		vReceiveBuffer[BitIndex] = DataBit;

		if ( DataBit > 0 )
		{
			ParityBitError = !ParityBitError;
     d00:	61 2c       	mov	r6, r1

	ParityBitError = 1;

	for( BitIndex = 0 ; BitIndex < 10 ; BitIndex++ )
	{
		DataBit = ( *READ_PORT_ADDRESS >> ucDataBitNumber ) & 0x01;
     d02:	f6 01       	movw	r30, r12
     d04:	80 81       	ld	r24, Z
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	08 2c       	mov	r0, r8
     d0a:	02 c0       	rjmp	.+4      	; 0xd10 <Read_Ps2_Byte+0x72>
     d0c:	95 95       	asr	r25
     d0e:	87 95       	ror	r24
     d10:	0a 94       	dec	r0
     d12:	e2 f7       	brpl	.-8      	; 0xd0c <Read_Ps2_Byte+0x6e>
     d14:	81 70       	andi	r24, 0x01	; 1
     d16:	89 83       	std	Y+1, r24	; 0x01
		vReceiveBuffer[BitIndex] = DataBit;
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	89 81       	ldd	r24, Y+1	; 0x01
     d1c:	e3 e0       	ldi	r30, 0x03	; 3
     d1e:	f0 e0       	ldi	r31, 0x00	; 0
     d20:	ec 0f       	add	r30, r28
     d22:	fd 1f       	adc	r31, r29
     d24:	e9 0f       	add	r30, r25
     d26:	f1 1d       	adc	r31, r1
     d28:	80 83       	st	Z, r24

		if ( DataBit > 0 )
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
     d2c:	88 23       	and	r24, r24
     d2e:	b9 f0       	breq	.+46     	; 0xd5e <Read_Ps2_Byte+0xc0>
		{
			ParityBitError = !ParityBitError;
     d30:	9e 85       	ldd	r25, Y+14	; 0x0e
     d32:	87 2d       	mov	r24, r7
     d34:	91 11       	cpse	r25, r1
     d36:	86 2d       	mov	r24, r6
     d38:	8e 87       	std	Y+14, r24	; 0x0e

			if (( BitIndex > 0 ) && ( BitIndex < 9 ))
     d3a:	8a 81       	ldd	r24, Y+2	; 0x02
     d3c:	88 23       	and	r24, r24
     d3e:	79 f0       	breq	.+30     	; 0xd5e <Read_Ps2_Byte+0xc0>
     d40:	8a 81       	ldd	r24, Y+2	; 0x02
     d42:	89 30       	cpi	r24, 0x09	; 9
     d44:	60 f4       	brcc	.+24     	; 0xd5e <Read_Ps2_Byte+0xc0>
				ReceivedByte |= ( 1 << ( BitIndex - 1 ));
     d46:	8a 81       	ldd	r24, Y+2	; 0x02
     d48:	2f 85       	ldd	r18, Y+15	; 0x0f
     d4a:	81 50       	subi	r24, 0x01	; 1
     d4c:	a5 01       	movw	r20, r10
     d4e:	02 c0       	rjmp	.+4      	; 0xd54 <Read_Ps2_Byte+0xb6>
     d50:	44 0f       	add	r20, r20
     d52:	55 1f       	adc	r21, r21
     d54:	8a 95       	dec	r24
     d56:	e2 f7       	brpl	.-8      	; 0xd50 <Read_Ps2_Byte+0xb2>
     d58:	ca 01       	movw	r24, r20
     d5a:	82 2b       	or	r24, r18
     d5c:	8f 87       	std	Y+15, r24	; 0x0f
		}

		Set_Port_Bit( WRITE_PORT_ADDRESS , ucClockBitNumber , 1 );
     d5e:	47 2d       	mov	r20, r7
     d60:	69 2d       	mov	r22, r9
     d62:	c7 01       	movw	r24, r14
     d64:	68 dc       	rcall	.-1840   	; 0x636 <Set_Port_Bit>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d66:	5a e1       	ldi	r21, 0x1A	; 26
     d68:	5a 95       	dec	r21
     d6a:	f1 f7       	brne	.-4      	; 0xd68 <Read_Ps2_Byte+0xca>
     d6c:	00 c0       	rjmp	.+0      	; 0xd6e <Read_Ps2_Byte+0xd0>
		_delay_us(CLOCK_PERIOD_uSec);
		Set_Port_Bit( WRITE_PORT_ADDRESS , ucClockBitNumber , 0 );
     d6e:	46 2d       	mov	r20, r6
     d70:	69 2d       	mov	r22, r9
     d72:	c7 01       	movw	r24, r14
     d74:	60 dc       	rcall	.-1856   	; 0x636 <Set_Port_Bit>
     d76:	8a e1       	ldi	r24, 0x1A	; 26
     d78:	8a 95       	dec	r24
     d7a:	f1 f7       	brne	.-4      	; 0xd78 <Read_Ps2_Byte+0xda>
     d7c:	00 c0       	rjmp	.+0      	; 0xd7e <Read_Ps2_Byte+0xe0>
										ParityBitError										=	0,
										ReceivedByte										=	0;

	ParityBitError = 1;

	for( BitIndex = 0 ; BitIndex < 10 ; BitIndex++ )
     d7e:	8a 81       	ldd	r24, Y+2	; 0x02
     d80:	8f 5f       	subi	r24, 0xFF	; 255
     d82:	8a 83       	std	Y+2, r24	; 0x02
     d84:	8a 81       	ldd	r24, Y+2	; 0x02
     d86:	8a 30       	cpi	r24, 0x0A	; 10
     d88:	08 f4       	brcc	.+2      	; 0xd8c <Read_Ps2_Byte+0xee>
     d8a:	bb cf       	rjmp	.-138    	; 0xd02 <Read_Ps2_Byte+0x64>
		_delay_us(CLOCK_PERIOD_uSec);
		Set_Port_Bit( WRITE_PORT_ADDRESS , ucClockBitNumber , 0 );
		_delay_us(CLOCK_PERIOD_uSec);
	}

	*pucDataByte = ReceivedByte;
     d8c:	8f 85       	ldd	r24, Y+15	; 0x0f
     d8e:	d8 01       	movw	r26, r16
     d90:	8c 93       	st	X, r24

	return ParityBitError;
     d92:	8e 85       	ldd	r24, Y+14	; 0x0e
}
     d94:	2f 96       	adiw	r28, 0x0f	; 15
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	de bf       	out	0x3e, r29	; 62
     d9c:	0f be       	out	0x3f, r0	; 63
     d9e:	cd bf       	out	0x3d, r28	; 61
     da0:	df 91       	pop	r29
     da2:	cf 91       	pop	r28
     da4:	1f 91       	pop	r17
     da6:	0f 91       	pop	r16
     da8:	ff 90       	pop	r15
     daa:	ef 90       	pop	r14
     dac:	df 90       	pop	r13
     dae:	cf 90       	pop	r12
     db0:	bf 90       	pop	r11
     db2:	af 90       	pop	r10
     db4:	9f 90       	pop	r9
     db6:	8f 90       	pop	r8
     db8:	7f 90       	pop	r7
     dba:	6f 90       	pop	r6
     dbc:	08 95       	ret

00000dbe <Write_Ps2_ACK>:

void Write_Ps2_ACK( volatile uint8_t *PORT_ADDRESS , unsigned char ucClockBitNumber , unsigned char ucDataBitNumber )
{
     dbe:	0f 93       	push	r16
     dc0:	1f 93       	push	r17
     dc2:	cf 93       	push	r28
     dc4:	df 93       	push	r29
     dc6:	ec 01       	movw	r28, r24
     dc8:	16 2f       	mov	r17, r22
     dca:	04 2f       	mov	r16, r20
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 1 );
     dcc:	41 e0       	ldi	r20, 0x01	; 1
     dce:	33 dc       	rcall	.-1946   	; 0x636 <Set_Port_Bit>
	Set_Port_Bit( PORT_ADDRESS , ucDataBitNumber , 1 );
     dd0:	41 e0       	ldi	r20, 0x01	; 1
     dd2:	60 2f       	mov	r22, r16
     dd4:	ce 01       	movw	r24, r28
     dd6:	2f dc       	rcall	.-1954   	; 0x636 <Set_Port_Bit>
     dd8:	8a e1       	ldi	r24, 0x1A	; 26
     dda:	8a 95       	dec	r24
     ddc:	f1 f7       	brne	.-4      	; 0xdda <Write_Ps2_ACK+0x1c>
     dde:	00 c0       	rjmp	.+0      	; 0xde0 <Write_Ps2_ACK+0x22>
	_delay_us(CLOCK_PERIOD_uSec);
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 0 );
     de0:	40 e0       	ldi	r20, 0x00	; 0
     de2:	61 2f       	mov	r22, r17
     de4:	ce 01       	movw	r24, r28
     de6:	27 dc       	rcall	.-1970   	; 0x636 <Set_Port_Bit>
     de8:	8a e1       	ldi	r24, 0x1A	; 26
     dea:	8a 95       	dec	r24
     dec:	f1 f7       	brne	.-4      	; 0xdea <Write_Ps2_ACK+0x2c>
     dee:	00 c0       	rjmp	.+0      	; 0xdf0 <Write_Ps2_ACK+0x32>
	_delay_us(CLOCK_PERIOD_uSec);
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 1 );
     df0:	41 e0       	ldi	r20, 0x01	; 1
     df2:	61 2f       	mov	r22, r17
     df4:	ce 01       	movw	r24, r28
     df6:	1f dc       	rcall	.-1986   	; 0x636 <Set_Port_Bit>
	Set_Port_Bit( PORT_ADDRESS , ucDataBitNumber , 0 );
     df8:	40 e0       	ldi	r20, 0x00	; 0
     dfa:	60 2f       	mov	r22, r16
     dfc:	ce 01       	movw	r24, r28
     dfe:	1b dc       	rcall	.-1994   	; 0x636 <Set_Port_Bit>
     e00:	8a e1       	ldi	r24, 0x1A	; 26
     e02:	8a 95       	dec	r24
     e04:	f1 f7       	brne	.-4      	; 0xe02 <Write_Ps2_ACK+0x44>
     e06:	00 c0       	rjmp	.+0      	; 0xe08 <Write_Ps2_ACK+0x4a>
	_delay_us(CLOCK_PERIOD_uSec);
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 0 );
     e08:	40 e0       	ldi	r20, 0x00	; 0
     e0a:	61 2f       	mov	r22, r17
     e0c:	ce 01       	movw	r24, r28
     e0e:	13 dc       	rcall	.-2010   	; 0x636 <Set_Port_Bit>
     e10:	8a e1       	ldi	r24, 0x1A	; 26
     e12:	8a 95       	dec	r24
     e14:	f1 f7       	brne	.-4      	; 0xe12 <Write_Ps2_ACK+0x54>
     e16:	00 c0       	rjmp	.+0      	; 0xe18 <Write_Ps2_ACK+0x5a>
	_delay_us(CLOCK_PERIOD_uSec);
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 1 );
     e18:	41 e0       	ldi	r20, 0x01	; 1
     e1a:	61 2f       	mov	r22, r17
     e1c:	ce 01       	movw	r24, r28
     e1e:	0b dc       	rcall	.-2026   	; 0x636 <Set_Port_Bit>
	Set_Port_Bit( PORT_ADDRESS , ucDataBitNumber , 1 );
     e20:	41 e0       	ldi	r20, 0x01	; 1
     e22:	60 2f       	mov	r22, r16
     e24:	ce 01       	movw	r24, r28
     e26:	07 dc       	rcall	.-2034   	; 0x636 <Set_Port_Bit>
}
     e28:	df 91       	pop	r29
     e2a:	cf 91       	pop	r28
     e2c:	1f 91       	pop	r17
     e2e:	0f 91       	pop	r16
     e30:	08 95       	ret

00000e32 <Write_Ps2_Byte>:

void Write_Ps2_Byte( volatile uint8_t *PORT_ADDRESS , unsigned char ucClockBitNumber , unsigned char ucDataBitNumber , unsigned char ucDataByte )
{
     e32:	ef 92       	push	r14
     e34:	ff 92       	push	r15
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	cd b7       	in	r28, 0x3d	; 61
     e40:	de b7       	in	r29, 0x3e	; 62
     e42:	2f 97       	sbiw	r28, 0x0f	; 15
     e44:	0f b6       	in	r0, 0x3f	; 63
     e46:	f8 94       	cli
     e48:	de bf       	out	0x3e, r29	; 62
     e4a:	0f be       	out	0x3f, r0	; 63
     e4c:	cd bf       	out	0x3d, r28	; 61
     e4e:	8c 01       	movw	r16, r24
     e50:	f6 2e       	mov	r15, r22
     e52:	e4 2e       	mov	r14, r20
	volatile unsigned char			BitIndex											=	0,
     e54:	19 82       	std	Y+1, r1	; 0x01
										ByteIndex											=	0;
     e56:	1a 82       	std	Y+2, r1	; 0x02

	volatile unsigned char			vSendBuffer[11]										=	{0},
     e58:	fe 01       	movw	r30, r28
     e5a:	33 96       	adiw	r30, 0x03	; 3
     e5c:	8b e0       	ldi	r24, 0x0B	; 11
     e5e:	df 01       	movw	r26, r30
     e60:	1d 92       	st	X+, r1
     e62:	8a 95       	dec	r24
     e64:	e9 f7       	brne	.-6      	; 0xe60 <Write_Ps2_Byte+0x2e>
										ParityOddBit										=	0,
     e66:	1e 86       	std	Y+14, r1	; 0x0e
										PrepareData											=	0;
     e68:	1f 86       	std	Y+15, r1	; 0x0f

	ParityOddBit = 1;
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	8e 87       	std	Y+14, r24	; 0x0e

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
     e6e:	19 82       	std	Y+1, r1	; 0x01
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	88 30       	cpi	r24, 0x08	; 8
     e74:	30 f5       	brcc	.+76     	; 0xec2 <Write_Ps2_Byte+0x90>
	{
		PrepareData = ( ucDataByte >> BitIndex ) & 0x01;
     e76:	30 e0       	ldi	r19, 0x00	; 0

		if ( PrepareData )
			ParityOddBit = !ParityOddBit;
     e78:	41 e0       	ldi	r20, 0x01	; 1
     e7a:	50 e0       	ldi	r21, 0x00	; 0

	ParityOddBit = 1;

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
	{
		PrepareData = ( ucDataByte >> BitIndex ) & 0x01;
     e7c:	89 81       	ldd	r24, Y+1	; 0x01
     e7e:	b9 01       	movw	r22, r18
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <Write_Ps2_Byte+0x54>
     e82:	75 95       	asr	r23
     e84:	67 95       	ror	r22
     e86:	8a 95       	dec	r24
     e88:	e2 f7       	brpl	.-8      	; 0xe82 <Write_Ps2_Byte+0x50>
     e8a:	cb 01       	movw	r24, r22
     e8c:	81 70       	andi	r24, 0x01	; 1
     e8e:	8f 87       	std	Y+15, r24	; 0x0f

		if ( PrepareData )
     e90:	8f 85       	ldd	r24, Y+15	; 0x0f
     e92:	88 23       	and	r24, r24
     e94:	29 f0       	breq	.+10     	; 0xea0 <Write_Ps2_Byte+0x6e>
			ParityOddBit = !ParityOddBit;
     e96:	9e 85       	ldd	r25, Y+14	; 0x0e
     e98:	84 2f       	mov	r24, r20
     e9a:	91 11       	cpse	r25, r1
     e9c:	85 2f       	mov	r24, r21
     e9e:	8e 87       	std	Y+14, r24	; 0x0e

		vSendBuffer[BitIndex+1] = PrepareData;
     ea0:	e9 81       	ldd	r30, Y+1	; 0x01
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	31 96       	adiw	r30, 0x01	; 1
     ea6:	8f 85       	ldd	r24, Y+15	; 0x0f
     ea8:	a3 e0       	ldi	r26, 0x03	; 3
     eaa:	b0 e0       	ldi	r27, 0x00	; 0
     eac:	ac 0f       	add	r26, r28
     eae:	bd 1f       	adc	r27, r29
     eb0:	ea 0f       	add	r30, r26
     eb2:	fb 1f       	adc	r31, r27
     eb4:	80 83       	st	Z, r24
										ParityOddBit										=	0,
										PrepareData											=	0;

	ParityOddBit = 1;

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
     eb6:	89 81       	ldd	r24, Y+1	; 0x01
     eb8:	8f 5f       	subi	r24, 0xFF	; 255
     eba:	89 83       	std	Y+1, r24	; 0x01
     ebc:	89 81       	ldd	r24, Y+1	; 0x01
     ebe:	88 30       	cpi	r24, 0x08	; 8
     ec0:	e8 f2       	brcs	.-70     	; 0xe7c <Write_Ps2_Byte+0x4a>
			ParityOddBit = !ParityOddBit;

		vSendBuffer[BitIndex+1] = PrepareData;
	}

	vSendBuffer[0] = 0;
     ec2:	1b 82       	std	Y+3, r1	; 0x03
	vSendBuffer[9] = ParityOddBit;
     ec4:	8e 85       	ldd	r24, Y+14	; 0x0e
     ec6:	8c 87       	std	Y+12, r24	; 0x0c
	vSendBuffer[10] = 1;
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	8d 87       	std	Y+13, r24	; 0x0d

	for( ByteIndex = 0 ; ByteIndex < 11 ; ByteIndex++ )
     ecc:	1a 82       	std	Y+2, r1	; 0x02
     ece:	8a 81       	ldd	r24, Y+2	; 0x02
     ed0:	8b 30       	cpi	r24, 0x0B	; 11
     ed2:	40 f5       	brcc	.+80     	; 0xf24 <Write_Ps2_Byte+0xf2>
	{
		if ( ByteIndex )
     ed4:	8a 81       	ldd	r24, Y+2	; 0x02
     ed6:	88 23       	and	r24, r24
     ed8:	21 f0       	breq	.+8      	; 0xee2 <Write_Ps2_Byte+0xb0>
     eda:	bd e0       	ldi	r27, 0x0D	; 13
     edc:	ba 95       	dec	r27
     ede:	f1 f7       	brne	.-4      	; 0xedc <Write_Ps2_Byte+0xaa>
     ee0:	00 00       	nop
			_delay_us(HALF_CLOCK_PERIOD_uSec);

		Set_Port_Bit( PORT_ADDRESS , ucDataBitNumber , vSendBuffer[ByteIndex] );
     ee2:	8a 81       	ldd	r24, Y+2	; 0x02
     ee4:	e3 e0       	ldi	r30, 0x03	; 3
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	ec 0f       	add	r30, r28
     eea:	fd 1f       	adc	r31, r29
     eec:	e8 0f       	add	r30, r24
     eee:	f1 1d       	adc	r31, r1
     ef0:	40 81       	ld	r20, Z
     ef2:	6e 2d       	mov	r22, r14
     ef4:	c8 01       	movw	r24, r16
     ef6:	9f db       	rcall	.-2242   	; 0x636 <Set_Port_Bit>
     ef8:	6d e0       	ldi	r22, 0x0D	; 13
     efa:	6a 95       	dec	r22
     efc:	f1 f7       	brne	.-4      	; 0xefa <Write_Ps2_Byte+0xc8>
     efe:	00 00       	nop
		_delay_us(HALF_CLOCK_PERIOD_uSec);
		Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 0 );
     f00:	40 e0       	ldi	r20, 0x00	; 0
     f02:	6f 2d       	mov	r22, r15
     f04:	c8 01       	movw	r24, r16
     f06:	97 db       	rcall	.-2258   	; 0x636 <Set_Port_Bit>
     f08:	7a e1       	ldi	r23, 0x1A	; 26
     f0a:	7a 95       	dec	r23
     f0c:	f1 f7       	brne	.-4      	; 0xf0a <Write_Ps2_Byte+0xd8>
     f0e:	00 c0       	rjmp	.+0      	; 0xf10 <Write_Ps2_Byte+0xde>
		_delay_us(CLOCK_PERIOD_uSec);
		Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 1 );
     f10:	41 e0       	ldi	r20, 0x01	; 1
     f12:	6f 2d       	mov	r22, r15
     f14:	c8 01       	movw	r24, r16
     f16:	8f db       	rcall	.-2274   	; 0x636 <Set_Port_Bit>

	vSendBuffer[0] = 0;
	vSendBuffer[9] = ParityOddBit;
	vSendBuffer[10] = 1;

	for( ByteIndex = 0 ; ByteIndex < 11 ; ByteIndex++ )
     f18:	8a 81       	ldd	r24, Y+2	; 0x02
     f1a:	8f 5f       	subi	r24, 0xFF	; 255
     f1c:	8a 83       	std	Y+2, r24	; 0x02
     f1e:	8a 81       	ldd	r24, Y+2	; 0x02
     f20:	8b 30       	cpi	r24, 0x0B	; 11
     f22:	c0 f2       	brcs	.-80     	; 0xed4 <Write_Ps2_Byte+0xa2>
		_delay_us(HALF_CLOCK_PERIOD_uSec);
		Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 0 );
		_delay_us(CLOCK_PERIOD_uSec);
		Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 1 );
	}
}
     f24:	2f 96       	adiw	r28, 0x0f	; 15
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	de bf       	out	0x3e, r29	; 62
     f2c:	0f be       	out	0x3f, r0	; 63
     f2e:	cd bf       	out	0x3d, r28	; 61
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	1f 91       	pop	r17
     f36:	0f 91       	pop	r16
     f38:	ff 90       	pop	r15
     f3a:	ef 90       	pop	r14
     f3c:	08 95       	ret

00000f3e <Push_PS2_Byte>:


void Push_PS2_Byte( volatile uint8_t *READ_PORT_ADDRESS , volatile uint8_t *WRITE_PORT_ADDRESS , unsigned char ucClockBitNumber , unsigned char ucDataBitNumber , unsigned char ucDataByte )
{
     f3e:	bf 92       	push	r11
     f40:	cf 92       	push	r12
     f42:	df 92       	push	r13
     f44:	ef 92       	push	r14
     f46:	ff 92       	push	r15
     f48:	0f 93       	push	r16
     f4a:	1f 93       	push	r17
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	cd b7       	in	r28, 0x3d	; 61
     f52:	de b7       	in	r29, 0x3e	; 62
     f54:	60 97       	sbiw	r28, 0x10	; 16
     f56:	0f b6       	in	r0, 0x3f	; 63
     f58:	f8 94       	cli
     f5a:	de bf       	out	0x3e, r29	; 62
     f5c:	0f be       	out	0x3f, r0	; 63
     f5e:	cd bf       	out	0x3d, r28	; 61
     f60:	7c 01       	movw	r14, r24
     f62:	6b 01       	movw	r12, r22
     f64:	14 2f       	mov	r17, r20
     f66:	b2 2e       	mov	r11, r18
	volatile unsigned char			index												=	0;
     f68:	19 82       	std	Y+1, r1	; 0x01

	volatile unsigned char			ClockBit											=	0;
     f6a:	1a 82       	std	Y+2, r1	; 0x02

	volatile unsigned char			BitIndex											=	0,
     f6c:	1b 82       	std	Y+3, r1	; 0x03
										BitFound											=	0;
     f6e:	1c 82       	std	Y+4, r1	; 0x04

	volatile unsigned char			vSendBuffer[11]										=	{0},
     f70:	fe 01       	movw	r30, r28
     f72:	35 96       	adiw	r30, 0x05	; 5
     f74:	9b e0       	ldi	r25, 0x0B	; 11
     f76:	df 01       	movw	r26, r30
     f78:	1d 92       	st	X+, r1
     f7a:	9a 95       	dec	r25
     f7c:	e9 f7       	brne	.-6      	; 0xf78 <Push_PS2_Byte+0x3a>
										PortReadData										=	0;
     f7e:	18 8a       	std	Y+16, r1	; 0x10

	unsigned char						ParityOddBit										=	0;

	ParityOddBit = 1;

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
     f80:	1b 82       	std	Y+3, r1	; 0x03
     f82:	9b 81       	ldd	r25, Y+3	; 0x03
     f84:	98 30       	cpi	r25, 0x08	; 8
     f86:	58 f5       	brcc	.+86     	; 0xfde <Push_PS2_Byte+0xa0>
	volatile unsigned char			vSendBuffer[11]										=	{0},
										PortReadData										=	0;

	unsigned char						ParityOddBit										=	0;

	ParityOddBit = 1;
     f88:	41 e0       	ldi	r20, 0x01	; 1

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
	{
		vSendBuffer[BitIndex+1] = ( ucDataByte >> BitIndex ) & 0x01;
     f8a:	80 2f       	mov	r24, r16
     f8c:	90 e0       	ldi	r25, 0x00	; 0

		if ( vSendBuffer[BitIndex+1] )
			ParityOddBit = !ParityOddBit;
     f8e:	51 e0       	ldi	r21, 0x01	; 1
     f90:	60 e0       	ldi	r22, 0x00	; 0

	ParityOddBit = 1;

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
	{
		vSendBuffer[BitIndex+1] = ( ucDataByte >> BitIndex ) & 0x01;
     f92:	eb 81       	ldd	r30, Y+3	; 0x03
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	31 96       	adiw	r30, 0x01	; 1
     f98:	2b 81       	ldd	r18, Y+3	; 0x03
     f9a:	dc 01       	movw	r26, r24
     f9c:	02 c0       	rjmp	.+4      	; 0xfa2 <Push_PS2_Byte+0x64>
     f9e:	b5 95       	asr	r27
     fa0:	a7 95       	ror	r26
     fa2:	2a 95       	dec	r18
     fa4:	e2 f7       	brpl	.-8      	; 0xf9e <Push_PS2_Byte+0x60>
     fa6:	9d 01       	movw	r18, r26
     fa8:	21 70       	andi	r18, 0x01	; 1
     faa:	a5 e0       	ldi	r26, 0x05	; 5
     fac:	b0 e0       	ldi	r27, 0x00	; 0
     fae:	ac 0f       	add	r26, r28
     fb0:	bd 1f       	adc	r27, r29
     fb2:	ea 0f       	add	r30, r26
     fb4:	fb 1f       	adc	r31, r27
     fb6:	20 83       	st	Z, r18

		if ( vSendBuffer[BitIndex+1] )
     fb8:	eb 81       	ldd	r30, Y+3	; 0x03
     fba:	f0 e0       	ldi	r31, 0x00	; 0
     fbc:	31 96       	adiw	r30, 0x01	; 1
     fbe:	ea 0f       	add	r30, r26
     fc0:	fb 1f       	adc	r31, r27
     fc2:	20 81       	ld	r18, Z
     fc4:	22 23       	and	r18, r18
     fc6:	21 f0       	breq	.+8      	; 0xfd0 <Push_PS2_Byte+0x92>
			ParityOddBit = !ParityOddBit;
     fc8:	25 2f       	mov	r18, r21
     fca:	41 11       	cpse	r20, r1
     fcc:	26 2f       	mov	r18, r22
     fce:	42 2f       	mov	r20, r18

	unsigned char						ParityOddBit										=	0;

	ParityOddBit = 1;

	for( BitIndex = 0 ; BitIndex < 8 ; BitIndex++ )
     fd0:	2b 81       	ldd	r18, Y+3	; 0x03
     fd2:	2f 5f       	subi	r18, 0xFF	; 255
     fd4:	2b 83       	std	Y+3, r18	; 0x03
     fd6:	2b 81       	ldd	r18, Y+3	; 0x03
     fd8:	28 30       	cpi	r18, 0x08	; 8
     fda:	d8 f2       	brcs	.-74     	; 0xf92 <Push_PS2_Byte+0x54>
     fdc:	01 c0       	rjmp	.+2      	; 0xfe0 <Push_PS2_Byte+0xa2>
	volatile unsigned char			vSendBuffer[11]										=	{0},
										PortReadData										=	0;

	unsigned char						ParityOddBit										=	0;

	ParityOddBit = 1;
     fde:	41 e0       	ldi	r20, 0x01	; 1

		if ( vSendBuffer[BitIndex+1] )
			ParityOddBit = !ParityOddBit;
	}

	vSendBuffer[9] = ParityOddBit;
     fe0:	4e 87       	std	Y+14, r20	; 0x0e
	vSendBuffer[10] = 1;
     fe2:	81 e0       	ldi	r24, 0x01	; 1
     fe4:	8f 87       	std	Y+15, r24	; 0x0f

	for ( BitIndex = 0; BitIndex < 11 ; BitIndex++ )
     fe6:	1b 82       	std	Y+3, r1	; 0x03
     fe8:	8b 81       	ldd	r24, Y+3	; 0x03
     fea:	8b 30       	cpi	r24, 0x0B	; 11
     fec:	90 f5       	brcc	.+100    	; 0x1052 <Push_PS2_Byte+0x114>
				}
				else
					break;
			}

			BitFound = 1;
     fee:	01 e0       	ldi	r16, 0x01	; 1
	vSendBuffer[9] = ParityOddBit;
	vSendBuffer[10] = 1;

	for ( BitIndex = 0; BitIndex < 11 ; BitIndex++ )
	{
		BitFound = 0;
     ff0:	1c 82       	std	Y+4, r1	; 0x04

		for( index = 0 ; index < 100 ; index++ )
     ff2:	19 82       	std	Y+1, r1	; 0x01
     ff4:	89 81       	ldd	r24, Y+1	; 0x01
     ff6:	84 36       	cpi	r24, 0x64	; 100
     ff8:	30 f5       	brcc	.+76     	; 0x1046 <Push_PS2_Byte+0x108>
		{
			PortReadData = *READ_PORT_ADDRESS;
     ffa:	f7 01       	movw	r30, r14
     ffc:	80 81       	ld	r24, Z
     ffe:	88 8b       	std	Y+16, r24	; 0x10

			ClockBit = ( PortReadData >> ucClockBitNumber ) & 0x01;
    1000:	e8 89       	ldd	r30, Y+16	; 0x10
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	01 2e       	mov	r0, r17
    1006:	02 c0       	rjmp	.+4      	; 0x100c <Push_PS2_Byte+0xce>
    1008:	f5 95       	asr	r31
    100a:	e7 95       	ror	r30
    100c:	0a 94       	dec	r0
    100e:	e2 f7       	brpl	.-8      	; 0x1008 <Push_PS2_Byte+0xca>
    1010:	e1 70       	andi	r30, 0x01	; 1
    1012:	ea 83       	std	Y+2, r30	; 0x02

			if ( ClockBit == 1 )
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	81 30       	cpi	r24, 0x01	; 1
    1018:	79 f4       	brne	.+30     	; 0x1038 <Push_PS2_Byte+0xfa>
			{
				if ( BitFound == 0 )
    101a:	8c 81       	ldd	r24, Y+4	; 0x04
    101c:	81 11       	cpse	r24, r1
    101e:	13 c0       	rjmp	.+38     	; 0x1046 <Push_PS2_Byte+0x108>
				{
					Set_Port_Bit( WRITE_PORT_ADDRESS , ucDataBitNumber , vSendBuffer[BitIndex] );
    1020:	8b 81       	ldd	r24, Y+3	; 0x03
    1022:	e5 e0       	ldi	r30, 0x05	; 5
    1024:	f0 e0       	ldi	r31, 0x00	; 0
    1026:	ec 0f       	add	r30, r28
    1028:	fd 1f       	adc	r31, r29
    102a:	e8 0f       	add	r30, r24
    102c:	f1 1d       	adc	r31, r1
    102e:	40 81       	ld	r20, Z
    1030:	6b 2d       	mov	r22, r11
    1032:	c6 01       	movw	r24, r12
    1034:	00 db       	rcall	.-2560   	; 0x636 <Set_Port_Bit>
					continue;
    1036:	01 c0       	rjmp	.+2      	; 0x103a <Push_PS2_Byte+0xfc>
				}
				else
					break;
			}

			BitFound = 1;
    1038:	0c 83       	std	Y+4, r16	; 0x04

	for ( BitIndex = 0; BitIndex < 11 ; BitIndex++ )
	{
		BitFound = 0;

		for( index = 0 ; index < 100 ; index++ )
    103a:	89 81       	ldd	r24, Y+1	; 0x01
    103c:	8f 5f       	subi	r24, 0xFF	; 255
    103e:	89 83       	std	Y+1, r24	; 0x01
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	84 36       	cpi	r24, 0x64	; 100
    1044:	d0 f2       	brcs	.-76     	; 0xffa <Push_PS2_Byte+0xbc>
	}

	vSendBuffer[9] = ParityOddBit;
	vSendBuffer[10] = 1;

	for ( BitIndex = 0; BitIndex < 11 ; BitIndex++ )
    1046:	8b 81       	ldd	r24, Y+3	; 0x03
    1048:	8f 5f       	subi	r24, 0xFF	; 255
    104a:	8b 83       	std	Y+3, r24	; 0x03
    104c:	8b 81       	ldd	r24, Y+3	; 0x03
    104e:	8b 30       	cpi	r24, 0x0B	; 11
    1050:	78 f2       	brcs	.-98     	; 0xff0 <Push_PS2_Byte+0xb2>
			BitFound = 1;
		};
	}

	return;
}
    1052:	60 96       	adiw	r28, 0x10	; 16
    1054:	0f b6       	in	r0, 0x3f	; 63
    1056:	f8 94       	cli
    1058:	de bf       	out	0x3e, r29	; 62
    105a:	0f be       	out	0x3f, r0	; 63
    105c:	cd bf       	out	0x3d, r28	; 61
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	1f 91       	pop	r17
    1064:	0f 91       	pop	r16
    1066:	ff 90       	pop	r15
    1068:	ef 90       	pop	r14
    106a:	df 90       	pop	r13
    106c:	cf 90       	pop	r12
    106e:	bf 90       	pop	r11
    1070:	08 95       	ret

00001072 <Write_Ps2_HOST_REQUEST>:

void Write_Ps2_HOST_REQUEST( volatile uint8_t *PORT_ADDRESS , unsigned char ucClockBitNumber , unsigned char ucDataBitNumber )
{
    1072:	0f 93       	push	r16
    1074:	1f 93       	push	r17
    1076:	cf 93       	push	r28
    1078:	df 93       	push	r29
    107a:	ec 01       	movw	r28, r24
    107c:	16 2f       	mov	r17, r22
    107e:	04 2f       	mov	r16, r20
	Set_Port_Bit( PORT_ADDRESS , ucDataBitNumber , 1 );
    1080:	41 e0       	ldi	r20, 0x01	; 1
    1082:	60 2f       	mov	r22, r16
    1084:	d8 da       	rcall	.-2640   	; 0x636 <Set_Port_Bit>
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 0 );
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	61 2f       	mov	r22, r17
    108a:	ce 01       	movw	r24, r28
    108c:	d4 da       	rcall	.-2648   	; 0x636 <Set_Port_Bit>
    108e:	80 ea       	ldi	r24, 0xA0	; 160
    1090:	8a 95       	dec	r24
    1092:	f1 f7       	brne	.-4      	; 0x1090 <Write_Ps2_HOST_REQUEST+0x1e>
	_delay_us(IDLE_PERIOD_uSec);
	Set_Port_Bit( PORT_ADDRESS , ucDataBitNumber , 0 );
    1094:	40 e0       	ldi	r20, 0x00	; 0
    1096:	60 2f       	mov	r22, r16
    1098:	ce 01       	movw	r24, r28
    109a:	cd da       	rcall	.-2662   	; 0x636 <Set_Port_Bit>
    109c:	8a e1       	ldi	r24, 0x1A	; 26
    109e:	8a 95       	dec	r24
    10a0:	f1 f7       	brne	.-4      	; 0x109e <Write_Ps2_HOST_REQUEST+0x2c>
    10a2:	00 c0       	rjmp	.+0      	; 0x10a4 <Write_Ps2_HOST_REQUEST+0x32>
	_delay_us(CLOCK_PERIOD_uSec);
	Set_Port_Bit( PORT_ADDRESS , ucClockBitNumber , 1 );
    10a4:	41 e0       	ldi	r20, 0x01	; 1
    10a6:	61 2f       	mov	r22, r17
    10a8:	ce 01       	movw	r24, r28
    10aa:	c5 da       	rcall	.-2678   	; 0x636 <Set_Port_Bit>
}
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	1f 91       	pop	r17
    10b2:	0f 91       	pop	r16
    10b4:	08 95       	ret

000010b6 <EnableDeviceInterrupt>:
    PCMSK2 |= (1 << PCINT22);  // set PCINT22 to trigger an interrupt on state change
}

void EnableDeviceInterrupt( unsigned char Enable )
{
	if ( Enable > 0 )
    10b6:	88 23       	and	r24, r24
    10b8:	39 f0       	breq	.+14     	; 0x10c8 <EnableDeviceInterrupt+0x12>
	{
		EIMSK |= ( 1 << INT0 );  //Enable INT0
    10ba:	e8 9a       	sbi	0x1d, 0	; 29
	    EICRA |= ( 1 << ISC01 ); //Trigger on falling edge of INT0
    10bc:	e9 e6       	ldi	r30, 0x69	; 105
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	82 60       	ori	r24, 0x02	; 2
    10c4:	80 83       	st	Z, r24
    10c6:	08 95       	ret
	}
	else
	{
		EIMSK = 0;  //Disable INT0
    10c8:	1d ba       	out	0x1d, r1	; 29
	    EICRA = 0;
    10ca:	10 92 69 00 	sts	0x0069, r1
    10ce:	08 95       	ret

000010d0 <Ps2Init>:
//--------------- Device Side Interrupts --------------------//
void Ps2Init(void)
{
	unsigned char x = 0;

	DEV_TO_HOST_Ps2Head = x;
    10d0:	10 92 2b 01 	sts	0x012B, r1
	DEV_TO_HOST_Ps2Tail = x;
    10d4:	10 92 2a 01 	sts	0x012A, r1

	HOST_TO_DEV_Ps2Head = x;
    10d8:	10 92 09 01 	sts	0x0109, r1
	HOST_TO_DEV_Ps2Tail = x;
    10dc:	10 92 08 01 	sts	0x0108, r1

	EnableDeviceInterrupt(1);
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	e9 df       	rcall	.-46     	; 0x10b6 <EnableDeviceInterrupt>

    PCICR |= (1 << PCIE2);    // set PCIE2 to enable PCMSK2 scan
    10e4:	e8 e6       	ldi	r30, 0x68	; 104
    10e6:	f0 e0       	ldi	r31, 0x00	; 0
    10e8:	80 81       	ld	r24, Z
    10ea:	84 60       	ori	r24, 0x04	; 4
    10ec:	80 83       	st	Z, r24
    PCMSK2 |= (1 << PCINT22);  // set PCINT22 to trigger an interrupt on state change
    10ee:	ed e6       	ldi	r30, 0x6D	; 109
    10f0:	f0 e0       	ldi	r31, 0x00	; 0
    10f2:	80 81       	ld	r24, Z
    10f4:	80 64       	ori	r24, 0x40	; 64
    10f6:	80 83       	st	Z, r24
    10f8:	08 95       	ret

000010fa <__vector_1>:
	    EICRA = 0;
	}
}

ISR(INT0_vect)
{
    10fa:	1f 92       	push	r1
    10fc:	0f 92       	push	r0
    10fe:	0f b6       	in	r0, 0x3f	; 63
    1100:	0f 92       	push	r0
    1102:	11 24       	eor	r1, r1
    1104:	2f 93       	push	r18
    1106:	3f 93       	push	r19
    1108:	4f 93       	push	r20
    110a:	5f 93       	push	r21
    110c:	6f 93       	push	r22
    110e:	7f 93       	push	r23
    1110:	8f 93       	push	r24
    1112:	9f 93       	push	r25
    1114:	af 93       	push	r26
    1116:	bf 93       	push	r27
    1118:	ef 93       	push	r30
    111a:	ff 93       	push	r31
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
    1120:	1f 92       	push	r1
    1122:	cd b7       	in	r28, 0x3d	; 61
    1124:	de b7       	in	r29, 0x3e	; 62
	unsigned char		CurrentReceivedByte		=	0,
    1126:	19 82       	std	Y+1, r1	; 0x01
						CurrentBufferIndex		=	0;

	unsigned char		Error					=	2;

	cli();
    1128:	f8 94       	cli

	Error = Sniffer_PS2_Byte( &PIND , DEVICE_CLOCK_BIT , DEVICE_DATA_BIT , &CurrentReceivedByte );
    112a:	9e 01       	movw	r18, r28
    112c:	2f 5f       	subi	r18, 0xFF	; 255
    112e:	3f 4f       	sbci	r19, 0xFF	; 255
    1130:	47 e0       	ldi	r20, 0x07	; 7
    1132:	62 e0       	ldi	r22, 0x02	; 2
    1134:	89 e2       	ldi	r24, 0x29	; 41
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	09 dd       	rcall	.-1518   	; 0xb4c <Sniffer_PS2_Byte>

	if ( Error == 0 )
    113a:	81 11       	cpse	r24, r1
    113c:	12 c0       	rjmp	.+36     	; 0x1162 <__vector_1+0x68>
	{
		CurrentBufferIndex = ( DEV_TO_HOST_Ps2Head + 1 ) & PS2_BUFFER_MASK;
    113e:	e0 91 2b 01 	lds	r30, 0x012B
    1142:	ef 5f       	subi	r30, 0xFF	; 255
    1144:	ef 71       	andi	r30, 0x1F	; 31
		DEV_TO_HOST_Ps2Head = CurrentBufferIndex;      /* Store new index */
    1146:	e0 93 2b 01 	sts	0x012B, r30

		if ( CurrentBufferIndex == DEV_TO_HOST_Ps2Tail )
    114a:	80 91 2a 01 	lds	r24, 0x012A
		{

		}

		DEV_TO_HOST_Ps2Buf[CurrentBufferIndex] = CurrentReceivedByte; /* Store received data in buffer */
    114e:	f0 e0       	ldi	r31, 0x00	; 0
    1150:	e4 5d       	subi	r30, 0xD4	; 212
    1152:	fe 4f       	sbci	r31, 0xFE	; 254
    1154:	89 81       	ldd	r24, Y+1	; 0x01
    1156:	80 83       	st	Z, r24

		Set_Port_Bit( &PORTC , GREEN_LED_BIT , LED_ON );								// Green LED ON ( Device Sending )
    1158:	40 e0       	ldi	r20, 0x00	; 0
    115a:	61 e0       	ldi	r22, 0x01	; 1
    115c:	88 e2       	ldi	r24, 0x28	; 40
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	6a da       	rcall	.-2860   	; 0x636 <Set_Port_Bit>
	}

	sei();
    1162:	78 94       	sei
}
    1164:	0f 90       	pop	r0
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	ff 91       	pop	r31
    116c:	ef 91       	pop	r30
    116e:	bf 91       	pop	r27
    1170:	af 91       	pop	r26
    1172:	9f 91       	pop	r25
    1174:	8f 91       	pop	r24
    1176:	7f 91       	pop	r23
    1178:	6f 91       	pop	r22
    117a:	5f 91       	pop	r21
    117c:	4f 91       	pop	r20
    117e:	3f 91       	pop	r19
    1180:	2f 91       	pop	r18
    1182:	0f 90       	pop	r0
    1184:	0f be       	out	0x3f, r0	; 63
    1186:	0f 90       	pop	r0
    1188:	1f 90       	pop	r1
    118a:	18 95       	reti

0000118c <IsDataInPs2SnifferBuffer>:

unsigned char IsDataInPs2SnifferBuffer( void )
{
	return ( DEV_TO_HOST_Ps2Head != DEV_TO_HOST_Ps2Tail ); /* Return 0 (FALSE) if the receive buffer is empty */
    118c:	20 91 2b 01 	lds	r18, 0x012B
    1190:	90 91 2a 01 	lds	r25, 0x012A
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	29 13       	cpse	r18, r25
    1198:	01 c0       	rjmp	.+2      	; 0x119c <IsDataInPs2SnifferBuffer+0x10>
    119a:	80 e0       	ldi	r24, 0x00	; 0
}
    119c:	08 95       	ret

0000119e <GetDataFromPs2SnifferBuffer>:

unsigned char GetDataFromPs2SnifferBuffer( void )
{
	unsigned char CurrentBufferIndex;

	CurrentBufferIndex = ( DEV_TO_HOST_Ps2Tail + 1 ) & PS2_BUFFER_MASK;/* Calculate buffer index */
    119e:	e0 91 2a 01 	lds	r30, 0x012A
    11a2:	ef 5f       	subi	r30, 0xFF	; 255
    11a4:	ef 71       	andi	r30, 0x1F	; 31

	DEV_TO_HOST_Ps2Tail = CurrentBufferIndex;
    11a6:	e0 93 2a 01 	sts	0x012A, r30

	return DEV_TO_HOST_Ps2Buf[CurrentBufferIndex];  /* Return data */
    11aa:	f0 e0       	ldi	r31, 0x00	; 0
    11ac:	e4 5d       	subi	r30, 0xD4	; 212
    11ae:	fe 4f       	sbci	r31, 0xFE	; 254
}
    11b0:	80 81       	ld	r24, Z
    11b2:	08 95       	ret

000011b4 <__vector_5>:

//--------------- Host Side Interrupts --------------------//

ISR (PCINT2_vect)
{
    11b4:	1f 92       	push	r1
    11b6:	0f 92       	push	r0
    11b8:	0f b6       	in	r0, 0x3f	; 63
    11ba:	0f 92       	push	r0
    11bc:	11 24       	eor	r1, r1
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	2f 93       	push	r18
    11c4:	3f 93       	push	r19
    11c6:	4f 93       	push	r20
    11c8:	5f 93       	push	r21
    11ca:	6f 93       	push	r22
    11cc:	7f 93       	push	r23
    11ce:	8f 93       	push	r24
    11d0:	9f 93       	push	r25
    11d2:	af 93       	push	r26
    11d4:	bf 93       	push	r27
    11d6:	ef 93       	push	r30
    11d8:	ff 93       	push	r31
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	00 d0       	rcall	.+0      	; 0x11e0 <__vector_5+0x2c>
    11e0:	00 d0       	rcall	.+0      	; 0x11e2 <__vector_5+0x2e>
    11e2:	cd b7       	in	r28, 0x3d	; 61
    11e4:	de b7       	in	r29, 0x3e	; 62
	volatile unsigned char			DataBit												=	0;
    11e6:	19 82       	std	Y+1, r1	; 0x01
	volatile unsigned char			CurrentReceivedByte									=	0,
    11e8:	1a 82       	std	Y+2, r1	; 0x02
										CurrentBufferIndex									=	0;
    11ea:	1b 82       	std	Y+3, r1	; 0x03

	volatile unsigned char			Error												=	2;
    11ec:	82 e0       	ldi	r24, 0x02	; 2
    11ee:	8c 83       	std	Y+4, r24	; 0x04

	DataBit = ( PIND >> HOST_DATA_BIT ) & 0x01;
    11f0:	89 b1       	in	r24, 0x09	; 9
    11f2:	86 fb       	bst	r24, 6
    11f4:	88 27       	eor	r24, r24
    11f6:	80 f9       	bld	r24, 0
    11f8:	89 83       	std	Y+1, r24	; 0x01

	if ( DataBit == 0 )
    11fa:	89 81       	ldd	r24, Y+1	; 0x01
    11fc:	81 11       	cpse	r24, r1
    11fe:	2c c0       	rjmp	.+88     	; 0x1258 <__vector_5+0xa4>
	{
		Set_Port_Bit( &PORTC , YELLOW_LED_BIT , LED_OFF );
    1200:	41 e0       	ldi	r20, 0x01	; 1
    1202:	62 e0       	ldi	r22, 0x02	; 2
    1204:	88 e2       	ldi	r24, 0x28	; 40
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	16 da       	rcall	.-3028   	; 0x636 <Set_Port_Bit>

		ReadingFromHostDirection();
    120a:	3b da       	rcall	.-2954   	; 0x682 <ReadingFromHostDirection>

		Error = Read_Ps2_Byte( &PIND, &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT , &CurrentReceivedByte );
    120c:	8e 01       	movw	r16, r28
    120e:	0e 5f       	subi	r16, 0xFE	; 254
    1210:	1f 4f       	sbci	r17, 0xFF	; 255
    1212:	26 e0       	ldi	r18, 0x06	; 6
    1214:	45 e0       	ldi	r20, 0x05	; 5
    1216:	6b e2       	ldi	r22, 0x2B	; 43
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	89 e2       	ldi	r24, 0x29	; 41
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	3f dd       	rcall	.-1410   	; 0xc9e <Read_Ps2_Byte>
    1220:	8c 83       	std	Y+4, r24	; 0x04

		SetDeviceToHostDirection();
    1222:	2a da       	rcall	.-2988   	; 0x678 <SetDeviceToHostDirection>

		Write_Ps2_ACK( &PORTD , HOST_CLOCK_BIT , HOST_DATA_BIT );
    1224:	46 e0       	ldi	r20, 0x06	; 6
    1226:	65 e0       	ldi	r22, 0x05	; 5
    1228:	8b e2       	ldi	r24, 0x2B	; 43
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	c8 dd       	rcall	.-1136   	; 0xdbe <Write_Ps2_ACK>

		if ( Error == 0 )
    122e:	8c 81       	ldd	r24, Y+4	; 0x04
    1230:	81 11       	cpse	r24, r1
    1232:	11 c0       	rjmp	.+34     	; 0x1256 <__vector_5+0xa2>
		{
			CurrentBufferIndex = ( HOST_TO_DEV_Ps2Head + 1 ) & PS2_BUFFER_MASK;
    1234:	80 91 09 01 	lds	r24, 0x0109
    1238:	8f 5f       	subi	r24, 0xFF	; 255
    123a:	8f 71       	andi	r24, 0x1F	; 31
    123c:	8b 83       	std	Y+3, r24	; 0x03
			HOST_TO_DEV_Ps2Head = CurrentBufferIndex;      /* Store new index */
    123e:	8b 81       	ldd	r24, Y+3	; 0x03
    1240:	80 93 09 01 	sts	0x0109, r24

			if ( CurrentBufferIndex == HOST_TO_DEV_Ps2Tail )
    1244:	8b 81       	ldd	r24, Y+3	; 0x03
    1246:	80 91 08 01 	lds	r24, 0x0108
			{

			}

			HOST_TO_DEV_Ps2Buf[CurrentBufferIndex] = CurrentReceivedByte; /* Store received data in buffer */
    124a:	eb 81       	ldd	r30, Y+3	; 0x03
    124c:	8a 81       	ldd	r24, Y+2	; 0x02
    124e:	f0 e0       	ldi	r31, 0x00	; 0
    1250:	e6 5f       	subi	r30, 0xF6	; 246
    1252:	fe 4f       	sbci	r31, 0xFE	; 254
    1254:	80 83       	st	Z, r24
		}

		ListeningtDirection();
    1256:	1a da       	rcall	.-3020   	; 0x68c <ListeningtDirection>
	}
}
    1258:	0f 90       	pop	r0
    125a:	0f 90       	pop	r0
    125c:	0f 90       	pop	r0
    125e:	0f 90       	pop	r0
    1260:	df 91       	pop	r29
    1262:	cf 91       	pop	r28
    1264:	ff 91       	pop	r31
    1266:	ef 91       	pop	r30
    1268:	bf 91       	pop	r27
    126a:	af 91       	pop	r26
    126c:	9f 91       	pop	r25
    126e:	8f 91       	pop	r24
    1270:	7f 91       	pop	r23
    1272:	6f 91       	pop	r22
    1274:	5f 91       	pop	r21
    1276:	4f 91       	pop	r20
    1278:	3f 91       	pop	r19
    127a:	2f 91       	pop	r18
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	0f 90       	pop	r0
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	0f 90       	pop	r0
    1286:	1f 90       	pop	r1
    1288:	18 95       	reti

0000128a <IsDataInPs2HostBuffer>:

unsigned char IsDataInPs2HostBuffer( void )
{
	return ( HOST_TO_DEV_Ps2Head != HOST_TO_DEV_Ps2Tail ); /* Return 0 (FALSE) if the receive buffer is empty */
    128a:	20 91 09 01 	lds	r18, 0x0109
    128e:	90 91 08 01 	lds	r25, 0x0108
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	29 13       	cpse	r18, r25
    1296:	01 c0       	rjmp	.+2      	; 0x129a <IsDataInPs2HostBuffer+0x10>
    1298:	80 e0       	ldi	r24, 0x00	; 0
}
    129a:	08 95       	ret

0000129c <GetDataFromPs2HostBuffer>:

unsigned char GetDataFromPs2HostBuffer( void )
{
	unsigned char CurrentBufferIndex;

	CurrentBufferIndex = ( HOST_TO_DEV_Ps2Tail + 1 ) & PS2_BUFFER_MASK;/* Calculate buffer index */
    129c:	e0 91 08 01 	lds	r30, 0x0108
    12a0:	ef 5f       	subi	r30, 0xFF	; 255
    12a2:	ef 71       	andi	r30, 0x1F	; 31

	HOST_TO_DEV_Ps2Tail = CurrentBufferIndex;
    12a4:	e0 93 08 01 	sts	0x0108, r30

	return HOST_TO_DEV_Ps2Buf[CurrentBufferIndex];  /* Return data */
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	e6 5f       	subi	r30, 0xF6	; 246
    12ac:	fe 4f       	sbci	r31, 0xFE	; 254
}
    12ae:	80 81       	ld	r24, Z
    12b0:	08 95       	ret

000012b2 <GetScanCode>:
	.num_of_items = 5,
	.CodeArray = {0xE0,0x71,0xE0,0xF0,0x71}
}};

int		GetScanCode( volatile unsigned char ASCII_key, volatile unsigned char *CodeArray )
{
    12b2:	cf 93       	push	r28
    12b4:	df 93       	push	r29
    12b6:	00 d0       	rcall	.+0      	; 0x12b8 <GetScanCode+0x6>
    12b8:	00 d0       	rcall	.+0      	; 0x12ba <GetScanCode+0x8>
    12ba:	cd b7       	in	r28, 0x3d	; 61
    12bc:	de b7       	in	r29, 0x3e	; 62
    12be:	8c 83       	std	Y+4, r24	; 0x04
	volatile unsigned char 	iIndex			=	0,
    12c0:	19 82       	std	Y+1, r1	; 0x01
								SizeOfList		=	0,
    12c2:	1a 82       	std	Y+2, r1	; 0x02
								NumberOfItems	=	0;
    12c4:	1b 82       	std	Y+3, r1	; 0x03

	SizeOfList = sizeof(ScanCodeList) / sizeof(tsScanCodeItem);
    12c6:	80 e8       	ldi	r24, 0x80	; 128
    12c8:	8a 83       	std	Y+2, r24	; 0x02

	if ( ASCII_key >= SizeOfList )
    12ca:	9c 81       	ldd	r25, Y+4	; 0x04
    12cc:	8a 81       	ldd	r24, Y+2	; 0x02
    12ce:	98 17       	cp	r25, r24
    12d0:	40 f5       	brcc	.+80     	; 0x1322 <GetScanCode+0x70>
		return 0;

	NumberOfItems = pgm_read_byte(&(ScanCodeList[ASCII_key].num_of_items));
    12d2:	ec 81       	ldd	r30, Y+4	; 0x04
    12d4:	8b e0       	ldi	r24, 0x0B	; 11
    12d6:	e8 9f       	mul	r30, r24
    12d8:	f0 01       	movw	r30, r0
    12da:	11 24       	eor	r1, r1
    12dc:	e2 58       	subi	r30, 0x82	; 130
    12de:	ff 4f       	sbci	r31, 0xFF	; 255
    12e0:	e4 91       	lpm	r30, Z
    12e2:	eb 83       	std	Y+3, r30	; 0x03

	for ( iIndex = 0; iIndex < NumberOfItems; iIndex++)
    12e4:	19 82       	std	Y+1, r1	; 0x01
    12e6:	99 81       	ldd	r25, Y+1	; 0x01
    12e8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ea:	98 17       	cp	r25, r24
    12ec:	b8 f4       	brcc	.+46     	; 0x131c <GetScanCode+0x6a>
		CodeArray[iIndex] = pgm_read_byte(&(ScanCodeList[ASCII_key].CodeArray[iIndex]));
    12ee:	2b e0       	ldi	r18, 0x0B	; 11
    12f0:	89 81       	ldd	r24, Y+1	; 0x01
    12f2:	db 01       	movw	r26, r22
    12f4:	a8 0f       	add	r26, r24
    12f6:	b1 1d       	adc	r27, r1
    12f8:	8c 81       	ldd	r24, Y+4	; 0x04
    12fa:	e9 81       	ldd	r30, Y+1	; 0x01
    12fc:	f0 e0       	ldi	r31, 0x00	; 0
    12fe:	28 9f       	mul	r18, r24
    1300:	e0 0d       	add	r30, r0
    1302:	f1 1d       	adc	r31, r1
    1304:	11 24       	eor	r1, r1
    1306:	e1 58       	subi	r30, 0x81	; 129
    1308:	ff 4f       	sbci	r31, 0xFF	; 255
    130a:	e4 91       	lpm	r30, Z
    130c:	ec 93       	st	X, r30
	if ( ASCII_key >= SizeOfList )
		return 0;

	NumberOfItems = pgm_read_byte(&(ScanCodeList[ASCII_key].num_of_items));

	for ( iIndex = 0; iIndex < NumberOfItems; iIndex++)
    130e:	89 81       	ldd	r24, Y+1	; 0x01
    1310:	8f 5f       	subi	r24, 0xFF	; 255
    1312:	89 83       	std	Y+1, r24	; 0x01
    1314:	99 81       	ldd	r25, Y+1	; 0x01
    1316:	8b 81       	ldd	r24, Y+3	; 0x03
    1318:	98 17       	cp	r25, r24
    131a:	50 f3       	brcs	.-44     	; 0x12f0 <GetScanCode+0x3e>
		CodeArray[iIndex] = pgm_read_byte(&(ScanCodeList[ASCII_key].CodeArray[iIndex]));

	return NumberOfItems;
    131c:	8b 81       	ldd	r24, Y+3	; 0x03
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	02 c0       	rjmp	.+4      	; 0x1326 <GetScanCode+0x74>
								NumberOfItems	=	0;

	SizeOfList = sizeof(ScanCodeList) / sizeof(tsScanCodeItem);

	if ( ASCII_key >= SizeOfList )
		return 0;
    1322:	80 e0       	ldi	r24, 0x00	; 0
    1324:	90 e0       	ldi	r25, 0x00	; 0

	for ( iIndex = 0; iIndex < NumberOfItems; iIndex++)
		CodeArray[iIndex] = pgm_read_byte(&(ScanCodeList[ASCII_key].CodeArray[iIndex]));

	return NumberOfItems;
}
    1326:	0f 90       	pop	r0
    1328:	0f 90       	pop	r0
    132a:	0f 90       	pop	r0
    132c:	0f 90       	pop	r0
    132e:	df 91       	pop	r29
    1330:	cf 91       	pop	r28
    1332:	08 95       	ret

00001334 <USART_Init>:
void USART_Init( unsigned int baudrate )
{
	unsigned char x;

	/* Set the baud rate */
	UBRR0H = (unsigned char) (baudrate>>8);
    1334:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char) baudrate;
    1338:	80 93 c4 00 	sts	0x00C4, r24

	UCSR0B |= (1 << RXEN0) | (1 << TXEN0); 						// Turn on the transmission and reception circuitry
    133c:	e1 ec       	ldi	r30, 0xC1	; 193
    133e:	f0 e0       	ldi	r31, 0x00	; 0
    1340:	80 81       	ld	r24, Z
    1342:	88 61       	ori	r24, 0x18	; 24
    1344:	80 83       	st	Z, r24
    UCSR0C = (0<<UMSEL01)|(0<<UMSEL00)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(0<<UCSZ02)|(1<<UCSZ01)|(1<<UCSZ00);
    1346:	86 e0       	ldi	r24, 0x06	; 6
    1348:	80 93 c2 00 	sts	0x00C2, r24

    UCSR0B |= ( 1 << RXCIE0 );									// Enable UART receiver Interrupt
    134c:	80 81       	ld	r24, Z
    134e:	80 68       	ori	r24, 0x80	; 128
    1350:	80 83       	st	Z, r24

    //UCSR0A |= ( 1 << U2X0 );
	/* Flush receive buffer */
	x = 0; 			    

	USART_RxTail = x;
    1352:	10 92 ce 01 	sts	0x01CE, r1
	USART_RxHead = x;
    1356:	10 92 cf 01 	sts	0x01CF, r1
	USART_TxTail = x;
    135a:	10 92 4c 01 	sts	0x014C, r1
	USART_TxHead = x;
    135e:	10 92 4d 01 	sts	0x014D, r1
    1362:	08 95       	ret

00001364 <__vector_18>:
}

/* Interrupt handlers */
ISR( USART_RX_vect )
{
    1364:	1f 92       	push	r1
    1366:	0f 92       	push	r0
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	0f 92       	push	r0
    136c:	11 24       	eor	r1, r1
    136e:	2f 93       	push	r18
    1370:	3f 93       	push	r19
    1372:	4f 93       	push	r20
    1374:	5f 93       	push	r21
    1376:	6f 93       	push	r22
    1378:	7f 93       	push	r23
    137a:	8f 93       	push	r24
    137c:	9f 93       	push	r25
    137e:	af 93       	push	r26
    1380:	bf 93       	push	r27
    1382:	ef 93       	push	r30
    1384:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;

	Set_Port_Bit( &PORTC , RED_LED_BIT , LED_ON );			// Red LED ON ( Rs232 Sending )
    1386:	40 e0       	ldi	r20, 0x00	; 0
    1388:	60 e0       	ldi	r22, 0x00	; 0
    138a:	88 e2       	ldi	r24, 0x28	; 40
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	53 d9       	rcall	.-3418   	; 0x636 <Set_Port_Bit>

	/* Read the received data */
	data = UDR0;
    1390:	80 91 c6 00 	lds	r24, 0x00C6
	/* Calculate buffer index */
	tmphead = ( USART_RxHead + 1 ) & USART_RX_BUFFER_MASK;
    1394:	e0 91 cf 01 	lds	r30, 0x01CF
    1398:	ef 5f       	subi	r30, 0xFF	; 255
    139a:	ef 77       	andi	r30, 0x7F	; 127
	USART_RxHead = tmphead;      /* Store new index */
    139c:	e0 93 cf 01 	sts	0x01CF, r30

	if ( tmphead == USART_RxTail )
    13a0:	90 91 ce 01 	lds	r25, 0x01CE
	{
		/* ERROR! Receive buffer overflow */
	}

	USART_RxBuf[tmphead] = data; /* Store received data in buffer */
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	e0 53       	subi	r30, 0x30	; 48
    13a8:	fe 4f       	sbci	r31, 0xFE	; 254
    13aa:	80 83       	st	Z, r24
}
    13ac:	ff 91       	pop	r31
    13ae:	ef 91       	pop	r30
    13b0:	bf 91       	pop	r27
    13b2:	af 91       	pop	r26
    13b4:	9f 91       	pop	r25
    13b6:	8f 91       	pop	r24
    13b8:	7f 91       	pop	r23
    13ba:	6f 91       	pop	r22
    13bc:	5f 91       	pop	r21
    13be:	4f 91       	pop	r20
    13c0:	3f 91       	pop	r19
    13c2:	2f 91       	pop	r18
    13c4:	0f 90       	pop	r0
    13c6:	0f be       	out	0x3f, r0	; 63
    13c8:	0f 90       	pop	r0
    13ca:	1f 90       	pop	r1
    13cc:	18 95       	reti

000013ce <__vector_19>:

ISR( USART_UDRE_vect )
{
    13ce:	1f 92       	push	r1
    13d0:	0f 92       	push	r0
    13d2:	0f b6       	in	r0, 0x3f	; 63
    13d4:	0f 92       	push	r0
    13d6:	11 24       	eor	r1, r1
    13d8:	8f 93       	push	r24
    13da:	9f 93       	push	r25
    13dc:	ef 93       	push	r30
    13de:	ff 93       	push	r31
	unsigned char tmptail;

	/* Check if all data is transmitted */
	if ( USART_TxHead != USART_TxTail )
    13e0:	90 91 4d 01 	lds	r25, 0x014D
    13e4:	80 91 4c 01 	lds	r24, 0x014C
    13e8:	98 17       	cp	r25, r24
    13ea:	69 f0       	breq	.+26     	; 0x1406 <__vector_19+0x38>
	{
		/* Calculate buffer index */
		tmptail = ( USART_TxTail + 1 ) & USART_TX_BUFFER_MASK;
    13ec:	e0 91 4c 01 	lds	r30, 0x014C
    13f0:	ef 5f       	subi	r30, 0xFF	; 255
    13f2:	ef 77       	andi	r30, 0x7F	; 127
		USART_TxTail = tmptail;      /* Store new index */
    13f4:	e0 93 4c 01 	sts	0x014C, r30
	
		UDR0 = USART_TxBuf[tmptail];  /* Start transmition */
    13f8:	f0 e0       	ldi	r31, 0x00	; 0
    13fa:	e2 5b       	subi	r30, 0xB2	; 178
    13fc:	fe 4f       	sbci	r31, 0xFE	; 254
    13fe:	80 81       	ld	r24, Z
    1400:	80 93 c6 00 	sts	0x00C6, r24
    1404:	05 c0       	rjmp	.+10     	; 0x1410 <__vector_19+0x42>
	}
	else
	{
		UCSR0B &= ~(1<<UDRIE0);         /* Disable UDRE interrupt */
    1406:	e1 ec       	ldi	r30, 0xC1	; 193
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	80 81       	ld	r24, Z
    140c:	8f 7d       	andi	r24, 0xDF	; 223
    140e:	80 83       	st	Z, r24
	}
}
    1410:	ff 91       	pop	r31
    1412:	ef 91       	pop	r30
    1414:	9f 91       	pop	r25
    1416:	8f 91       	pop	r24
    1418:	0f 90       	pop	r0
    141a:	0f be       	out	0x3f, r0	; 63
    141c:	0f 90       	pop	r0
    141e:	1f 90       	pop	r1
    1420:	18 95       	reti

00001422 <DataInReceiveBuffer>:
	UCSR0B |= (1<<UDRIE0);                    /* Enable UDRE interrupt */
}

unsigned char DataInReceiveBuffer( void )
{
	return ( USART_RxHead != USART_RxTail ); /* Return 0 (FALSE) if the receive buffer is empty */
    1422:	20 91 cf 01 	lds	r18, 0x01CF
    1426:	90 91 ce 01 	lds	r25, 0x01CE
    142a:	81 e0       	ldi	r24, 0x01	; 1
    142c:	29 13       	cpse	r18, r25
    142e:	01 c0       	rjmp	.+2      	; 0x1432 <DataInReceiveBuffer+0x10>
    1430:	80 e0       	ldi	r24, 0x00	; 0
}
    1432:	08 95       	ret

00001434 <GetDataFromReceiveBuffer>:

unsigned char GetDataFromReceiveBuffer( void )
{
	unsigned char tmptail;

	tmptail = ( USART_RxTail + 1 ) & USART_RX_BUFFER_MASK;/* Calculate buffer index */
    1434:	e0 91 ce 01 	lds	r30, 0x01CE
    1438:	ef 5f       	subi	r30, 0xFF	; 255
    143a:	ef 77       	andi	r30, 0x7F	; 127

	USART_RxTail = tmptail;
    143c:	e0 93 ce 01 	sts	0x01CE, r30

	return USART_RxBuf[tmptail];  /* Return data */
    1440:	f0 e0       	ldi	r31, 0x00	; 0
    1442:	e0 53       	subi	r30, 0x30	; 48
    1444:	fe 4f       	sbci	r31, 0xFE	; 254
}
    1446:	80 81       	ld	r24, Z
    1448:	08 95       	ret

0000144a <_exit>:
    144a:	f8 94       	cli

0000144c <__stop_program>:
    144c:	ff cf       	rjmp	.-2      	; 0x144c <__stop_program>
